name: Owner App Build (iOS) - External Testing Auto (Public Link + Auto Submit)

on:
  repository_dispatch:
    types: [owner_app_build_ios]

permissions:
  contents: write

jobs:
  build-ios:
    runs-on: macos-15

    env:
      CI_CALLBACK_TOKEN: ${{ secrets.CI_CALLBACK_TOKEN }}
      CI_RUNTIME_TOKEN: ${{ secrets.CI_RUNTIME_TOKEN }}

      IOS_P12_B64: ${{ secrets.IOS_P12_B64 }}
      IOS_P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
      IOS_TEAM_ID: ${{ secrets.IOS_TEAM_ID }}
      IOS_EXPORT_METHOD: ${{ secrets.IOS_EXPORT_METHOD }}

      ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
      ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
      ASC_KEY_P8_B64: ${{ secrets.ASC_KEY_P8_B64 }}

      # External testing defaults (can be overridden by payload CONFIG)
      DEFAULT_BETA_APP_DESCRIPTION: ${{ secrets.DEFAULT_BETA_APP_DESCRIPTION }}
      DEFAULT_BETA_FEEDBACK_EMAIL: ${{ secrets.DEFAULT_BETA_FEEDBACK_EMAIL }}
      DEFAULT_BETA_CONTACT_PHONE: ${{ secrets.DEFAULT_BETA_CONTACT_PHONE }}

      SPACESHIP_CONNECT_API_IN_HOUSE: "false"
      COCOAPODS_DISABLE_STATS: "true"
      FASTLANE_OPT_OUT_USAGE: "true"
      LANG: en_US.UTF-8
      LC_ALL: en_US.UTF-8

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select newest installed Xcode (safe)
        shell: bash
        run: |
          set -euo pipefail
          echo "üîé Installed Xcodes:"
          ls -1 /Applications | grep -E '^Xcode.*\.app$' || true
          XCODE_APP="$(ls -1 /Applications | grep -E '^Xcode.*\.app$' | sort -V | tail -n 1)"
          [ -n "${XCODE_APP:-}" ] || { echo "‚ùå No Xcode found"; exit 1; }
          echo "‚úÖ Selected: $XCODE_APP"
          sudo xcode-select -s "/Applications/$XCODE_APP/Contents/Developer"
          xcodebuild -version
          echo "iOS SDK: $(xcrun --sdk iphoneos --show-sdk-version)"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.32.0"
          channel: stable
          cache: true

      - name: Flutter pub get
        shell: bash
        run: |
          set -euo pipefail
          flutter --version
          flutter pub get

      - name: Show dispatch payload (debug)
        shell: bash
        run: |
          set -euo pipefail
          echo '${{ toJson(github.event.client_payload) }}'

      # ============================================================
      # 1) Build ci_env.json (your existing BY_LINK logic)
      # ============================================================
      - name: Build ci_env.json (BY_LINK runtime-config + fallback + B64)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p lib/env

          python3 - <<'PY'
          import json, os, urllib.request, urllib.error, socket, re

          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          api_base = (cfg.get("API_BASE_URL") or payload.get("API_BASE_URL") or "").rstrip("/")
          link_id = str(
              cfg.get("OWNER_PROJECT_LINK_ID")
              or payload.get("OWNER_PROJECT_LINK_ID")
              or payload.get("ownerProjectLinkId")
              or cfg.get("ownerProjectLinkId")
              or ""
          ).strip()

          if not api_base:
              raise SystemExit("Missing API_BASE_URL")
          if not link_id:
              raise SystemExit("Missing OWNER_PROJECT_LINK_ID")

          url = f"{api_base}/api/public/runtime-config/by-link?linkId={link_id}"
          runtime = {}
          source = "FALLBACK (payload/defaults)"

          token = (os.getenv("CI_RUNTIME_TOKEN") or "").strip()
          headers = {"Accept": "application/json"}
          if token:
              headers["X-Auth-Token"] = token

          try:
              print("Fetching runtime config:", url)
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=12) as r:
                  raw = r.read().decode("utf-8")
                  runtime = json.loads(raw)
              source = "BY_LINK"
          except (urllib.error.HTTPError, urllib.error.URLError, socket.timeout, json.JSONDecodeError) as e:
              print("‚ö†Ô∏è runtime-config fetch failed, using fallback:", repr(e))

          def pick(key, default=None):
              v = runtime.get(key)
              if v not in (None, "", []):
                  return v
              v = cfg.get(key)
              if v not in (None, "", []):
                  return v
              v = payload.get(key)
              if v not in (None, "", []):
                  return v
              return default

          app_name = pick("APP_NAME", "My App")
          app_type = pick("APP_TYPE", "ECOMMERCE")
          project_id = str(pick("PROJECT_ID", "")).strip()

          ios_bundle = (
              pick("iosBundleId") or 
              pick("IOS_BUNDLE_ID") or 
              pick("PACKAGE_NAME") or 
              pick("APPLICATION_ID") or 
              ""
          ).strip()

          if not ios_bundle:
              ios_bundle = f"com.build4all.app{link_id}"

          ios_bundle = ios_bundle.lower()
          ios_bundle = re.sub(r"[^a-z0-9._]", "", ios_bundle)
          ios_bundle = re.sub(r"\.+", ".", ios_bundle).strip(".")

          if not ios_bundle or ios_bundle.count(".") < 1:
              ios_bundle = f"com.build4all.app{link_id}"

          vc = pick("IOS_BUILD_NUMBER") or pick("iosBuildNumber") or pick("ANDROID_VERSION_CODE")
          vn = pick("IOS_VERSION_NAME") or pick("iosVersionName") or pick("ANDROID_VERSION_NAME")

          try:
              vc_int = int(vc) if vc not in (None,"",[]) else None
          except Exception:
              vc_int = None

          vn_str = (str(vn).strip() if vn not in (None,"",[]) else "")

          env = {
              "API_BASE_URL": api_base,
              "APP_NAME": app_name,
              "APP_TYPE": app_type,
              "OWNER_PROJECT_LINK_ID": link_id,
              "PROJECT_ID": project_id,
              "IOS_BUNDLE_ID": ios_bundle,
              "IOS_BUILD_NUMBER": vc_int if vc_int is not None else 1,
              "IOS_VERSION_NAME": vn_str if vn_str else "1.0.0",
              "CONFIG_SOURCE": source,
          }

          currency_id = pick("CURRENCY_ID") or runtime.get("currencyId") or cfg.get("currencyId") or payload.get("currencyId")
          if currency_id not in (None, "", []):
              env["CURRENCY_ID"] = str(currency_id).strip()

          for key in ["THEME_JSON_B64","NAV_JSON_B64","HOME_JSON_B64","ENABLED_FEATURES_JSON_B64","BRANDING_JSON_B64"]:
              v = pick(key)
              if v:
                  env[key] = v

          logo_url = (pick("LOGO_URL") or pick("LOGO_PATH") or "").strip()
          if not logo_url:
              logo_url = (runtime.get("logoUrl") or cfg.get("logoUrl") or payload.get("logoUrl") or "").strip()
          if logo_url:
              env["LOGO_URL"] = logo_url

          open("ci_api_base.txt", "w", encoding="utf-8").write(api_base)
          open("ci_link_id.txt", "w", encoding="utf-8").write(link_id)
          open("ci_ios_bundle_id.txt", "w", encoding="utf-8").write(ios_bundle)

          with open("lib/env/ci_env.json", "w", encoding="utf-8") as f:
              json.dump(env, f, ensure_ascii=False, indent=2)

          print("‚úÖ ci_env.json written")
          print("IOS_BUNDLE_ID =", ios_bundle)
          print("IOS_BUILD_NUMBER =", env["IOS_BUILD_NUMBER"])
          print("IOS_VERSION_NAME =", env["IOS_VERSION_NAME"])
          print("CONFIG_SOURCE =", source)
          PY

      - name: Debug env
        shell: bash
        run: |
          echo "----- ci_env.json -----"
          cat lib/env/ci_env.json

      # ============================================================
      # 2) Read Beta metadata (feedback email / phone / description)
      # ============================================================
      - name: Read App Store Connect metadata
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os
          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          def pick(*keys):
            for k in keys:
              if k in payload and payload[k]:
                return payload[k]
              if k in cfg and cfg[k]:
                return cfg[k]
            return ""

          beta_description = (
              pick("BETA_APP_DESCRIPTION","betaAppDescription")
              or os.environ.get("DEFAULT_BETA_APP_DESCRIPTION","")
              or "Test our app and provide feedback on features, usability, and overall experience."
          )

          feedback_email = (
              pick("BETA_FEEDBACK_EMAIL","betaFeedbackEmail","ownerEmail")
              or os.environ.get("DEFAULT_BETA_FEEDBACK_EMAIL","")
              or pick("ownerEmail")
              or ""
          )

          contact_phone = (
              pick("BETA_CONTACT_PHONE","betaContactPhone")
              or os.environ.get("DEFAULT_BETA_CONTACT_PHONE","")
              or "+1234567890"
          )

          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write(f"BETA_APP_DESCRIPTION={beta_description}\n")
            f.write(f"BETA_FEEDBACK_EMAIL={feedback_email}\n")
            f.write(f"BETA_CONTACT_PHONE={contact_phone}\n")

          print("BETA_APP_DESCRIPTION=", beta_description[:120] + "..." if len(beta_description) > 120 else beta_description)
          print("BETA_FEEDBACK_EMAIL=", feedback_email)
          print("BETA_CONTACT_PHONE=", contact_phone)
          PY

      - name: Ensure iOS Podfile exists
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f "ios/Podfile" ]; then
            flutter create .
          fi
          test -f ios/Podfile

      - name: Set iOS version & build number
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, re
          cfg = json.load(open("lib/env/ci_env.json"))
          version_name = str(cfg.get("IOS_VERSION_NAME","1.0.0")).strip()
          build_number = str(cfg.get("IOS_BUILD_NUMBER",1)).strip()

          info_plist = "ios/Runner/Info.plist"
          content = open(info_plist,"r",encoding="utf-8").read()

          content = re.sub(
              r"(<key>CFBundleShortVersionString</key>\s*<string>)[^<]*(</string>)",
              rf"\g<1>{version_name}\g<2>",
              content
          )
          content = re.sub(
              r"(<key>CFBundleVersion</key>\s*<string>)[^<]*(</string>)",
              rf"\g<1>{build_number}\g<2>",
              content
          )

          open(info_plist,"w",encoding="utf-8").write(content)
          print("‚úÖ Updated Info.plist version/build")
          PY

      - name: Add privacy strings to Info.plist
        shell: bash
        run: |
          set -euo pipefail
          INFO_PLIST="ios/Runner/Info.plist"
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs access to your photo library to allow you to select and upload images.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'This app needs access to your photo library to allow you to select and upload images.'" "$INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs access to your camera to allow you to take and upload photos.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'This app needs access to your camera to allow you to take and upload photos.'" "$INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save images to your photo library.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'This app needs permission to save images to your photo library.'" "$INFO_PLIST"
          echo "‚úÖ Privacy strings added"

      # ============================================================
      # 3) Signing + Pods + API Key
      # ============================================================
      - name: Setup iOS signing certificate
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${IOS_P12_B64:-}" ] || { echo "‚ùå Missing IOS_P12_B64"; exit 1; }
          [ -n "${IOS_P12_PASSWORD:-}" ] || { echo "‚ùå Missing IOS_P12_PASSWORD"; exit 1; }

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"

          security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db
          security default-keychain -s "$KEYCHAIN_PATH"

          echo "$IOS_P12_B64" | tr -d '\n\r ' | base64 --decode > ios_cert.p12
          security import ios_cert.p12 -k "$KEYCHAIN_PATH" -P "$IOS_P12_PASSWORD" -A \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          CNT=$(security find-identity -v -p codesigning | grep -c "Apple Distribution" || true)
          [ "$CNT" -ge 1 ] || { echo "‚ùå Apple Distribution identity not found"; exit 1; }

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"

      - name: Install CocoaPods + fastlane
        shell: bash
        run: |
          set -euo pipefail
          gem install cocoapods -N
          gem install fastlane -N
          pod --version
          fastlane --version

      - name: Clean Pods
        shell: bash
        run: |
          set -euo pipefail
          rm -rf ios/Pods
          rm -f ios/Podfile.lock

      - name: Install iOS Pods
        shell: bash
        run: |
          set -euo pipefail
          cd ios
          pod install || { pod repo update; pod install; }

      - name: Create App Store Connect api_key.json
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .private
          [ -n "${ASC_KEY_ID:-}" ] || { echo "‚ùå ASC_KEY_ID empty"; exit 1; }
          [ -n "${ASC_ISSUER_ID:-}" ] || { echo "‚ùå ASC_ISSUER_ID empty"; exit 1; }
          [ -n "${ASC_KEY_P8_B64:-}" ] || { echo "‚ùå ASC_KEY_P8_B64 empty"; exit 1; }

          echo "${ASC_KEY_P8_B64}" | base64 --decode > .private/AuthKey_${ASC_KEY_ID}.p8

          python3 - <<'PY'
          import json, pathlib, os
          key_path = pathlib.Path(f".private/AuthKey_{os.environ['ASC_KEY_ID']}.p8")
          p8_content = key_path.read_text(encoding="utf-8", errors="ignore")

          api_key_data = {
            "key_id": os.environ["ASC_KEY_ID"].strip(),
            "issuer_id": os.environ["ASC_ISSUER_ID"].strip(),
            "key": p8_content,
            "in_house": False
          }

          pathlib.Path(".private/api_key.json").write_text(
              json.dumps(api_key_data, ensure_ascii=False, indent=2)
          )
          print("‚úÖ api_key.json created")
          PY

      - name: Install required Python packages
        shell: bash
        run: |
          pip3 install PyJWT cryptography requests --break-system-packages

      # ============================================================
      # 4) Build IPA
      # ============================================================
      - name: Build iOS (no codesign)
        shell: bash
        run: |
          set -euo pipefail
          flutter build ios --release --no-codesign \
            --dart-define-from-file=lib/env/ci_env.json

      - name: Archive
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/archive
          cd ios

          xcodebuild \
            -workspace Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            archive

      - name: Export IPA
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/ipa
          cd ios

          # Minimal export options for app-store style export
          cat > ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>${IOS_EXPORT_METHOD:-app-store}</string>
            <key>destination</key>
            <string>export</string>
            <key>compileBitcode</key>
            <false/>
          </dict>
          </plist>
          EOF

          xcodebuild -exportArchive \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath ../build/ios/ipa \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa
          path: build/ios/ipa/**/*.ipa
          if-no-files-found: error

      # ============================================================
      # 5) Upload to TestFlight (UPLOAD ONLY)
      # ============================================================
      - name: Upload to TestFlight (Upload only)
        shell: bash
        run: |
          set -euo pipefail
          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          IPA_PATH="$(find "$GITHUB_WORKSPACE/build/ios/ipa" -type f -name "*.ipa" | head -n 1)"

          echo "üì§ Uploading IPA to TestFlight (upload only)..."
          fastlane pilot upload \
            --ipa "$IPA_PATH" \
            --api_key_path "$API_KEY_JSON" \
            --app_identifier "$BUNDLE_ID" \
            --skip_waiting_for_build_processing false \
            --skip_submission true \
            --changelog "Automated external beta"

          echo "‚úÖ Upload complete (processing waited)"

      # ============================================================
      # 6) External Group + Public Link + Add Build + Auto Submit
      # ============================================================
      - name: üöÄ External Testing (Public Link + Auto Submit)
        shell: bash
        run: |
          set -euo pipefail

          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          APP_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")"

          echo '${{ toJson(github.event.client_payload) }}' > /tmp/ci_payload.json

          python3 - <<'PY' > /tmp/owner_env.sh
          import json, shlex
          p = json.load(open("/tmp/ci_payload.json"))
          cfg = p.get("CONFIG") or {}

          owner_email = (cfg.get("ownerEmail") or p.get("ownerEmail") or "").strip()
          owner_name  = (cfg.get("ownerName") or p.get("ownerName") or "Owner").strip() or "Owner"

          print("OWNER_EMAIL=" + shlex.quote(owner_email))
          print("OWNER_NAME="  + shlex.quote(owner_name))
          PY

          source /tmp/owner_env.sh

          # NOTE: You can still do public link without a tester,
          # but Apple sometimes wants at least one tester in the group.
          # If ownerEmail is missing, we skip only the tester-add step.
          echo "üìß OWNER_EMAIL=${OWNER_EMAIL:-<none>}"
          echo "üë§ OWNER_NAME=${OWNER_NAME:-Owner}"
          echo "üì± APP_NAME=$APP_NAME"
          echo "üÜî BUNDLE_ID=$BUNDLE_ID"
          echo ""

          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "$APP_NAME" "${OWNER_EMAIL:-}" "${OWNER_NAME:-}" "${BETA_APP_DESCRIPTION:-}" "${BETA_FEEDBACK_EMAIL:-}" "${BETA_CONTACT_PHONE:-}" <<'PYEOF'
          import json, jwt, time, requests, sys

          api_key = json.load(open(sys.argv[1]))

          def token():
              return jwt.encode({
                  "iss": api_key["issuer_id"],
                  "iat": int(time.time()),
                  "exp": int(time.time()) + 1200,
                  "aud": "appstoreconnect-v1"
              }, api_key["key"], algorithm="ES256",
              headers={"kid": api_key["key_id"], "typ": "JWT"})

          def h():
              return {"Authorization": f"Bearer {token()}", "Content-Type": "application/json"}

          bundle_id = sys.argv[2]
          app_name = sys.argv[3]
          owner_email = (sys.argv[4] or "").strip()
          owner_name = (sys.argv[5] or "Owner").strip() or "Owner"
          beta_description = sys.argv[6] or f"Test {app_name} and provide feedback"
          feedback_email = (sys.argv[7] or owner_email or "").strip()
          contact_phone = (sys.argv[8] or "+1234567890").strip()

          GROUP_NAME = f"External - {app_name}".strip()

          print("="*70)
          print("üöÄ EXTERNAL TESTFLIGHT: PUBLIC LINK + AUTO SUBMIT")
          print("="*70)
          print(f"üì± App: {app_name}")
          print(f"üÜî Bundle: {bundle_id}")
          print(f"üë• Group: {GROUP_NAME}")
          print(f"üìß Feedback Email: {feedback_email}")
          print(f"üì± Contact Phone: {contact_phone}")
          print()

          # 1) Find App
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}", headers=h())
          r.raise_for_status()
          apps = r.json().get("data", [])
          if not apps:
              print("‚ùå App not found in App Store Connect")
              sys.exit(1)
          app_id = apps[0]["id"]
          print(f"‚úÖ App found: {app_id}")
          print()

          # 2) Beta localization (feedback + description)
          print("üìã Step 2: Beta Localization...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations?filter[app]={app_id}&filter[locale]=en-US",
              headers=h()
          )
          r.raise_for_status()
          existing = r.json().get("data", [])
          loc_attrs = {"feedbackEmail": feedback_email, "description": beta_description}

          if existing:
              loc_id = existing[0]["id"]
              r2 = requests.patch(
                  f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations/{loc_id}",
                  headers=h(),
                  json={"data":{"type":"betaAppLocalizations","id":loc_id,"attributes":loc_attrs}}
              )
              print("‚úÖ Beta localization updated" if r2.status_code == 200 else f"‚ö†Ô∏è Localization update {r2.status_code}")
          else:
              r2 = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaAppLocalizations",
                  headers=h(),
                  json={
                      "data":{
                          "type":"betaAppLocalizations",
                          "attributes":{"locale":"en-US", **loc_attrs},
                          "relationships":{"app":{"data":{"type":"apps","id":app_id}}}
                      }
                  }
              )
              print("‚úÖ Beta localization created" if r2.status_code in (200,201) else f"‚ö†Ô∏è Localization create {r2.status_code}")
          print()

          # 3) Beta review detail (required for external)
          print("üìã Step 3: Beta Review Detail...")
          review_data = {
              "contactEmail": feedback_email or owner_email or "test@example.com",
              "contactFirstName": (owner_name.split()[0] if owner_name else "Contact"),
              "contactLastName": (" ".join(owner_name.split()[1:]) if len(owner_name.split()) > 1 else "Person"),
              "contactPhone": contact_phone,
              "demoAccountRequired": False
          }

          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/apps/{app_id}/betaAppReviewDetail", headers=h())
          if r.status_code == 200:
              detail_id = r.json()["data"]["id"]
              r2 = requests.patch(
                  f"https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails/{detail_id}",
                  headers=h(),
                  json={"data":{"type":"betaAppReviewDetails","id":detail_id,"attributes":review_data}}
              )
              print("‚úÖ Beta review detail updated" if r2.status_code == 200 else f"‚ö†Ô∏è Beta review update {r2.status_code}")
          else:
              r2 = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails",
                  headers=h(),
                  json={
                      "data":{
                          "type":"betaAppReviewDetails",
                          "attributes":review_data,
                          "relationships":{"app":{"data":{"type":"apps","id":app_id}}}
                      }
                  }
              )
              print("‚úÖ Beta review detail created" if r2.status_code in (200,201) else f"‚ö†Ô∏è Beta review create {r2.status_code}")
          print()

          # 4) Find/create external group (by name)
          print("üë• Step 4: Group...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/betaGroups?filter[app]={app_id}&filter[isInternalGroup]=false&limit=200",
              headers=h()
          )
          r.raise_for_status()
          groups = r.json().get("data", [])

          group_id = None
          for g in groups:
              if (g.get("attributes", {}).get("name") == GROUP_NAME):
                  group_id = g["id"]
                  print(f"‚úÖ Group exists: {GROUP_NAME}")
                  break

          if not group_id:
              r2 = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaGroups",
                  headers=h(),
                  json={
                      "data":{
                          "type":"betaGroups",
                          "attributes":{
                              "name": GROUP_NAME,
                              "isInternalGroup": False,
                              "publicLinkEnabled": True,
                              "publicLinkLimitEnabled": False
                          },
                          "relationships":{"app":{"data":{"type":"apps","id":app_id}}}
                      }
                  }
              )
              r2.raise_for_status()
              group_id = r2.json()["data"]["id"]
              print(f"‚úÖ Group created: {GROUP_NAME}")
          print()

          # 4.5) Ensure public link resource exists + print it
          print("üîó Step 4.5: Public Link...")
          # Ensure flags
          requests.patch(
              f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}",
              headers=h(),
              json={"data":{"type":"betaGroups","id":group_id,"attributes":{"publicLinkEnabled":True,"publicLinkLimitEnabled":False}}}
          )

          link_url = None
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/betaGroupPublicLinks?filter[betaGroup]={group_id}",
              headers=h()
          )
          if r.status_code == 200 and r.json().get("data"):
              link_url = (r.json()["data"][0].get("attributes") or {}).get("publicLink")
              print("‚úÖ Public link exists:", link_url)
          else:
              r2 = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaGroupPublicLinks",
                  headers=h(),
                  json={"data":{"type":"betaGroupPublicLinks","relationships":{"betaGroup":{"data":{"type":"betaGroups","id":group_id}}}}}
              )
              if r2.status_code in (200,201):
                  link_url = (r2.json()["data"].get("attributes") or {}).get("publicLink")
                  print("‚úÖ Public link created:", link_url)
              else:
                  print(f"‚ö†Ô∏è Public link create failed: {r2.status_code}")
                  print(r2.text[:300])
          print()

          # 5) Optional: add tester to group (only if owner_email exists)
          if owner_email:
              print("üß™ Step 5: Tester...")
              tester_id = None
              r = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaTesters?filter[email]={owner_email}", headers=h())
              if r.status_code == 200 and r.json().get("data"):
                  tester_id = r.json()["data"][0]["id"]
                  print("‚úÖ Tester exists:", tester_id)
              else:
                  # create
                  first = owner_name.split()[0] if owner_name else "Owner"
                  last = " ".join(owner_name.split()[1:]) if len(owner_name.split()) > 1 else ""
                  r2 = requests.post(
                      "https://api.appstoreconnect.apple.com/v1/betaTesters",
                      headers=h(),
                      json={"data":{"type":"betaTesters","attributes":{"email":owner_email,"firstName":first,"lastName":last}}}
                  )
                  if r2.status_code in (200,201):
                      tester_id = r2.json()["data"]["id"]
                      print("‚úÖ Tester created:", tester_id)

              if tester_id:
                  r3 = requests.post(
                      f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/betaTesters",
                      headers=h(),
                      json={"data":[{"type":"betaTesters","id":tester_id}]}
                  )
                  if r3.status_code in (200,204):
                      print("‚úÖ Tester added to group")
                  elif r3.status_code == 409:
                      print("‚úÖ Tester already in group")
                  else:
                      print("‚ö†Ô∏è Add tester response:", r3.status_code)
              print()
          else:
              print("üß™ Step 5: Tester skipped (ownerEmail missing)")
              print()

          # 6) Find latest VALID build
          print("‚è≥ Step 6: Find VALID build...")
          build_id = None
          version = None
          build_num = None

          for attempt in range(20):
              r = requests.get(
                  f"https://api.appstoreconnect.apple.com/v1/builds?filter[app]={app_id}&sort=-uploadedDate&limit=1",
                  headers=h()
              )
              r.raise_for_status()
              data = r.json().get("data", [])
              if data:
                  b = data[0]
                  build_id = b["id"]
                  attrs = b.get("attributes") or {}
                  version = attrs.get("version")
                  build_num = attrs.get("buildNumber")
                  state = attrs.get("processingState","PROCESSING")
                  if state == "VALID":
                      print(f"‚úÖ Build ready: {version} ({build_num})")
                      break
                  print(f"‚è≥ Build {version} state={state} attempt {attempt+1}/20")
              else:
                  print(f"‚è≥ No builds yet attempt {attempt+1}/20")

              time.sleep(30)

          if not build_id:
              print("‚ö†Ô∏è No build detected. Exiting.")
              sys.exit(0)
          print()

          # 7) Export compliance
          print("üîí Step 7: Export compliance...")
          r = requests.patch(
              f"https://api.appstoreconnect.apple.com/v1/builds/{build_id}",
              headers=h(),
              json={"data":{"type":"builds","id":build_id,"attributes":{"usesNonExemptEncryption":False}}}
          )
          if r.status_code == 200:
              print("‚úÖ Export compliance set")
          elif r.status_code == 409:
              print("‚úÖ Export compliance already set")
          else:
              print("‚ÑπÔ∏è Export compliance response:", r.status_code)
          print()

          # 8) Add build to group
          print("üì¶ Step 8: Add build to group...")
          r = requests.post(
              f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/builds",
              headers=h(),
              json={"data":[{"type":"builds","id":build_id}]}
          )
          if r.status_code in (200,204):
              print("‚úÖ Build added to group")
          elif r.status_code == 409:
              print("‚úÖ Build already in group")
          else:
              print("‚ö†Ô∏è Add build response:", r.status_code)
              print(r.text[:300])
          print()

          # 9) AUTO SUBMIT for Beta Review (this is what removes ‚ÄúReady to Submit‚Äù)
          print("üöÄ Step 9: Submit for Beta Review...")
          r = requests.post(
              "https://api.appstoreconnect.apple.com/v1/betaAppReviewSubmissions",
              headers=h(),
              json={"data":{"type":"betaAppReviewSubmissions","relationships":{"build":{"data":{"type":"builds","id":build_id}}}}}
          )
          if r.status_code in (200,201):
              submission_id = r.json()["data"]["id"]
              print("‚úÖ Submitted for Beta Review! submission_id =", submission_id)
          elif r.status_code == 409:
              print("‚úÖ Already submitted (409)")
          else:
              print("‚ö†Ô∏è Submit response:", r.status_code)
              print(r.text[:400])

          print()
          print("="*70)
          print("üéâ DONE")
          print("="*70)
          print("üì± App:", app_name)
          print("üì¶ Build:", f"{version} ({build_num})")
          if link_url:
              print("üîó Public Link:", link_url)
          print("‚è≥ External review: usually 24‚Äì48 hours (Apple mood dependent üòÖ)")
          print("="*70)
          PYEOF
name: Owner App Build (iOS) - External Testing Auto (Public Link + Auto Submit)

on:
  repository_dispatch:
    types: [owner_app_build_ios]

permissions:
  contents: write

jobs:
  build-ios:
    runs-on: macos-15

    env:
      CI_CALLBACK_TOKEN: ${{ secrets.CI_CALLBACK_TOKEN }}
      CI_RUNTIME_TOKEN: ${{ secrets.CI_RUNTIME_TOKEN }}

      IOS_P12_B64: ${{ secrets.IOS_P12_B64 }}
      IOS_P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
      IOS_TEAM_ID: ${{ secrets.IOS_TEAM_ID }}
      IOS_EXPORT_METHOD: ${{ secrets.IOS_EXPORT_METHOD }}

      ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
      ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
      ASC_KEY_P8_B64: ${{ secrets.ASC_KEY_P8_B64 }}

      # Defaults for external beta (can override from payload CONFIG)
      DEFAULT_BETA_APP_DESCRIPTION: ${{ secrets.DEFAULT_BETA_APP_DESCRIPTION }}
      DEFAULT_BETA_FEEDBACK_EMAIL: ${{ secrets.DEFAULT_BETA_FEEDBACK_EMAIL }}
      DEFAULT_BETA_CONTACT_PHONE: ${{ secrets.DEFAULT_BETA_CONTACT_PHONE }}

      SPACESHIP_CONNECT_API_IN_HOUSE: "false"
      COCOAPODS_DISABLE_STATS: "true"
      FASTLANE_OPT_OUT_USAGE: "true"
      LANG: en_US.UTF-8
      LC_ALL: en_US.UTF-8

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select newest installed Xcode (safe)
        shell: bash
        run: |
          set -euo pipefail

          echo "üîé Installed Xcodes:"
          ls -1 /Applications | grep -E '^Xcode.*\.app$' || true

          XCODE_APP="$(ls -1 /Applications | grep -E '^Xcode.*\.app$' | sort -V | tail -n 1)"
          if [ -z "${XCODE_APP:-}" ]; then
            echo "‚ùå No Xcode found in /Applications"
            exit 1
          fi

          echo "‚úÖ Selected: $XCODE_APP"
          sudo xcode-select -s "/Applications/$XCODE_APP/Contents/Developer"

          xcodebuild -version
          echo "iOS SDK: $(xcrun --sdk iphoneos --show-sdk-version)"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.32.0"
          channel: stable
          cache: true

      - name: Flutter pub get
        shell: bash
        run: |
          set -euo pipefail
          flutter --version
          flutter pub get

      - name: Show dispatch payload (debug)
        shell: bash
        run: |
          set -euo pipefail
          echo '${{ toJson(github.event.client_payload) }}'

      # ============================================================
      # 1) Build ci_env.json (runtime-config by-link + fallback)
      # ============================================================
      - name: Build ci_env.json (BY_LINK runtime-config + fallback + B64)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p lib/env

          python3 - <<'PY'
          import json, os, urllib.request, urllib.error, socket, re

          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          api_base = (cfg.get("API_BASE_URL") or payload.get("API_BASE_URL") or "").rstrip("/")
          link_id = str(
              cfg.get("OWNER_PROJECT_LINK_ID")
              or payload.get("OWNER_PROJECT_LINK_ID")
              or payload.get("ownerProjectLinkId")
              or cfg.get("ownerProjectLinkId")
              or ""
          ).strip()

          if not api_base:
              raise SystemExit("Missing API_BASE_URL")
          if not link_id:
              raise SystemExit("Missing OWNER_PROJECT_LINK_ID")

          url = f"{api_base}/api/public/runtime-config/by-link?linkId={link_id}"
          runtime = {}
          source = "FALLBACK (payload/defaults)"

          token = (os.getenv("CI_RUNTIME_TOKEN") or "").strip()
          headers = {"Accept": "application/json"}
          if token:
              headers["X-Auth-Token"] = token

          try:
              print("Fetching runtime config:", url)
              print("Auth header present =", "YES" if token else "NO")
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=12) as r:
                  raw = r.read().decode("utf-8")
                  runtime = json.loads(raw)
              source = "BY_LINK"
          except (urllib.error.HTTPError, urllib.error.URLError, socket.timeout, json.JSONDecodeError) as e:
              print("‚ö†Ô∏è runtime-config fetch failed, using fallback:", repr(e))

          print("CONFIG SOURCE =", source)

          def pick(key, default=None):
              v = runtime.get(key)
              if v not in (None, "", []):
                  return v
              v = cfg.get(key)
              if v not in (None, "", []):
                  return v
              v = payload.get(key)
              if v not in (None, "", []):
                  return v
              return default

          app_name = pick("APP_NAME", "My App")
          app_type = pick("APP_TYPE", "ECOMMERCE")
          project_id = str(pick("PROJECT_ID", "")).strip()

          ios_bundle = (
              pick("iosBundleId") or
              pick("IOS_BUNDLE_ID") or
              pick("PACKAGE_NAME") or
              pick("APPLICATION_ID") or
              ""
          ).strip()

          if not ios_bundle:
              ios_bundle = f"com.build4all.app{link_id}"

          ios_bundle = ios_bundle.lower()
          ios_bundle = re.sub(r"[^a-z0-9._]", "", ios_bundle)
          ios_bundle = re.sub(r"\.+", ".", ios_bundle).strip(".")

          if not ios_bundle or ios_bundle.count(".") < 1:
              ios_bundle = f"com.build4all.app{link_id}"

          vc = pick("IOS_BUILD_NUMBER") or pick("iosBuildNumber") or pick("ANDROID_VERSION_CODE")
          vn = pick("IOS_VERSION_NAME") or pick("iosVersionName") or pick("ANDROID_VERSION_NAME")

          try:
              vc_int = int(vc) if vc not in (None,"",[]) else None
          except Exception:
              vc_int = None

          vn_str = (str(vn).strip() if vn not in (None,"",[]) else "")

          env = {
              "API_BASE_URL": api_base,
              "APP_NAME": app_name,
              "APP_TYPE": app_type,
              "OWNER_PROJECT_LINK_ID": link_id,
              "PROJECT_ID": project_id,
              "IOS_BUNDLE_ID": ios_bundle,
              "IOS_BUILD_NUMBER": vc_int if vc_int is not None else 1,
              "IOS_VERSION_NAME": vn_str if vn_str else "1.0.0",
              "CONFIG_SOURCE": source,
          }

          currency_id = pick("CURRENCY_ID")
          if currency_id in (None, "", []):
              currency_id = runtime.get("currencyId") or cfg.get("currencyId") or payload.get("currencyId")
          if currency_id not in (None, "", []):
              env["CURRENCY_ID"] = str(currency_id).strip()

          for key in [
              "THEME_JSON_B64",
              "NAV_JSON_B64",
              "HOME_JSON_B64",
              "ENABLED_FEATURES_JSON_B64",
              "BRANDING_JSON_B64",
          ]:
              v = pick(key)
              if v:
                  env[key] = v

          logo_url = (pick("LOGO_URL") or pick("LOGO_PATH") or "").strip()
          if not logo_url:
              logo_url = (runtime.get("logoUrl") or cfg.get("logoUrl") or payload.get("logoUrl") or "").strip()
          if logo_url:
              env["LOGO_URL"] = logo_url

          open("ci_api_base.txt", "w", encoding="utf-8").write(api_base)
          open("ci_link_id.txt", "w", encoding="utf-8").write(link_id)
          open("ci_ios_bundle_id.txt", "w", encoding="utf-8").write(ios_bundle)

          with open("lib/env/ci_env.json", "w", encoding="utf-8") as f:
              json.dump(env, f, ensure_ascii=False, indent=2)

          print("‚úÖ ci_env.json written")
          print("IOS_BUNDLE_ID =", ios_bundle)
          print("IOS_BUILD_NUMBER =", env["IOS_BUILD_NUMBER"])
          print("IOS_VERSION_NAME =", env["IOS_VERSION_NAME"])
          PY

      - name: Debug env
        shell: bash
        run: |
          echo "----- ci_env.json -----"
          cat lib/env/ci_env.json

      # ============================================================
      # 2) Read ASC metadata + beta defaults
      # ============================================================
      - name: Read App Store Connect metadata
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os
          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          def pick(*keys):
            for k in keys:
              if payload.get(k): return payload[k]
              if cfg.get(k): return cfg[k]
            return ""

          app_name = pick("APPLE_APP_NAME","appleAppName","appStoreAppName","ASC_APP_NAME")
          sku      = pick("APPLE_SKU","appleSku","appStoreSku","ASC_SKU")
          locale   = pick("APPLE_PRIMARY_LOCALE","applePrimaryLocale","primaryLocale","ASC_PRIMARY_LOCALE") or "en-US"

          beta_description = (
              pick("BETA_APP_DESCRIPTION","betaAppDescription")
              or os.environ.get("DEFAULT_BETA_APP_DESCRIPTION","")
              or "Test our app and provide feedback on features, usability, and overall experience."
          )

          feedback_email = (
              pick("BETA_FEEDBACK_EMAIL","betaFeedbackEmail","ownerEmail")
              or os.environ.get("DEFAULT_BETA_FEEDBACK_EMAIL","")
              or pick("ownerEmail")
              or ""
          )

          contact_phone = (
              pick("BETA_CONTACT_PHONE","betaContactPhone")
              or os.environ.get("DEFAULT_BETA_CONTACT_PHONE","")
              or "+1234567890"
          )

          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write(f"APPLE_APP_NAME={app_name}\n")
            f.write(f"APPLE_SKU={sku}\n")
            f.write(f"APPLE_PRIMARY_LOCALE={locale}\n")
            f.write(f"BETA_APP_DESCRIPTION={beta_description}\n")
            f.write(f"BETA_FEEDBACK_EMAIL={feedback_email}\n")
            f.write(f"BETA_CONTACT_PHONE={contact_phone}\n")

          print("BETA_FEEDBACK_EMAIL=", feedback_email)
          print("BETA_CONTACT_PHONE=", contact_phone)
          PY

      # ============================================================
      # 3) Ensure ios folder / Podfile exists
      # ============================================================
      - name: Ensure iOS Podfile exists
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f "ios/Podfile" ]; then
            flutter create .
          fi
          test -f ios/Podfile

      # ============================================================
      # 4) Update Info.plist version/build
      # ============================================================
      - name: Set iOS version & build number
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, re
          cfg = json.load(open("lib/env/ci_env.json"))
          version_name = str(cfg.get("IOS_VERSION_NAME","1.0.0")).strip()
          build_number = str(cfg.get("IOS_BUILD_NUMBER",1)).strip()

          info_plist = "ios/Runner/Info.plist"
          content = open(info_plist,"r",encoding="utf-8").read()

          content = re.sub(r"(<key>CFBundleShortVersionString</key>\s*<string>)[^<]*(</string>)",
                           rf"\g<1>{version_name}\g<2>", content)
          content = re.sub(r"(<key>CFBundleVersion</key>\s*<string>)[^<]*(</string>)",
                           rf"\g<1>{build_number}\g<2>", content)

          open(info_plist,"w",encoding="utf-8").write(content)
          print("‚úÖ Updated Info.plist", version_name, build_number)
          PY

      # ============================================================
      # 5) Add privacy strings
      # ============================================================
      - name: Add privacy strings to Info.plist
        shell: bash
        run: |
          set -euo pipefail
          INFO_PLIST="ios/Runner/Info.plist"

          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs access to your photo library to select and upload images.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'This app needs access to your photo library to select and upload images.'" "$INFO_PLIST"

          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs access to your camera to take and upload photos.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'This app needs access to your camera to take and upload photos.'" "$INFO_PLIST"

          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save images to your photo library.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'This app needs permission to save images to your photo library.'" "$INFO_PLIST"

          echo "‚úÖ Privacy strings added"

      # ============================================================
      # 6) Branding: download logo + run launcher/splash
      # ============================================================
      - name: Apply branding (logo + launcher + splash)
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json, urllib.request, pathlib, shutil

          cfg = json.load(open("lib/env/ci_env.json","r",encoding="utf-8"))
          app_name_raw = cfg.get("APP_NAME","My App")
          api_base = (cfg.get("API_BASE_URL") or "").rstrip("/")
          logo_url = (cfg.get("LOGO_URL") or "").strip()

          print("APP_NAME:", app_name_raw)
          print("LOGO_URL:", logo_url)

          pathlib.Path("assets/branding").mkdir(parents=True, exist_ok=True)

          if logo_url and logo_url.startswith("/") and api_base:
              logo_url = api_base + logo_url
              print("Resolved absolute LOGO_URL:", logo_url)

          if logo_url:
              try:
                  urllib.request.urlretrieve(logo_url, "assets/branding/logo.png")
                  shutil.copyfile("assets/branding/logo.png","assets/branding/launcher.png")
                  shutil.copyfile("assets/branding/logo.png","assets/branding/splash.png")
                  print("‚úÖ Logo downloaded")
              except Exception as e:
                  print("‚ö†Ô∏è Logo download failed:", e)
          else:
              print("‚ö†Ô∏è No LOGO_URL provided, skip logo download")
          PY

          flutter pub get
          flutter pub run flutter_launcher_icons || echo "‚ö†Ô∏è flutter_launcher_icons failed"
          flutter pub run flutter_native_splash:create || echo "‚ö†Ô∏è flutter_native_splash failed"

      - name: Set iOS App Name in Info.plist
        shell: bash
        run: |
          set -euo pipefail
          INFO_PLIST="ios/Runner/Info.plist"
          APP_NAME=$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")

          /usr/libexec/PlistBuddy -c "Add :CFBundleDisplayName string '$APP_NAME'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName '$APP_NAME'" "$INFO_PLIST"

          /usr/libexec/PlistBuddy -c "Add :CFBundleName string '$APP_NAME'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :CFBundleName '$APP_NAME'" "$INFO_PLIST"

          echo "‚úÖ iOS App Name set"

      # ============================================================
      # 7) Setup signing cert in keychain
      # ============================================================
      - name: Setup iOS signing certificate
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${IOS_P12_B64:-}" ] || { echo "‚ùå Missing IOS_P12_B64"; exit 1; }
          [ -n "${IOS_P12_PASSWORD:-}" ] || { echo "‚ùå Missing IOS_P12_PASSWORD"; exit 1; }

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"

          security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db
          security default-keychain -s "$KEYCHAIN_PATH"

          echo "$IOS_P12_B64" | tr -d '\n\r ' | base64 --decode > ios_cert.p12
          security import ios_cert.p12 -k "$KEYCHAIN_PATH" -P "$IOS_P12_PASSWORD" -A \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          CNT=$(security find-identity -v -p codesigning | grep -c "Apple Distribution" || true)
          if [ "$CNT" -lt 1 ]; then
            echo "‚ùå Apple Distribution identity not found"
            exit 1
          fi
          echo "‚úÖ Signing identity OK"

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"

      - name: Install CocoaPods + fastlane
        shell: bash
        run: |
          set -euo pipefail
          gem install cocoapods -N
          gem install fastlane -N
          pod --version
          fastlane --version

      - name: Clean Pods
        shell: bash
        run: |
          set -euo pipefail
          rm -rf ios/Pods
          rm -f ios/Podfile.lock

      - name: Install iOS Pods
        shell: bash
        run: |
          set -euo pipefail
          cd ios
          pod install || { pod repo update; pod install; }

      # ============================================================
      # 8) Create ASC api_key.json
      # ============================================================
      - name: Create App Store Connect api_key.json
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .private

          [ -n "${ASC_KEY_ID:-}" ] || { echo "‚ùå ASC_KEY_ID empty"; exit 1; }
          [ -n "${ASC_ISSUER_ID:-}" ] || { echo "‚ùå ASC_ISSUER_ID empty"; exit 1; }
          [ -n "${ASC_KEY_P8_B64:-}" ] || { echo "‚ùå ASC_KEY_P8_B64 empty"; exit 1; }

          echo "${ASC_KEY_P8_B64}" | base64 --decode > .private/AuthKey_${ASC_KEY_ID}.p8

          python3 - <<'PY'
          import json, pathlib, os
          key_path = pathlib.Path(f".private/AuthKey_{os.environ['ASC_KEY_ID']}.p8")
          p8_content = key_path.read_text(encoding="utf-8", errors="ignore")

          api_key_data = {
            "key_id": os.environ["ASC_KEY_ID"].strip(),
            "issuer_id": os.environ["ASC_ISSUER_ID"].strip(),
            "key": p8_content,
            "in_house": False
          }
          pathlib.Path(".private/api_key.json").write_text(json.dumps(api_key_data, indent=2))
          print("‚úÖ api_key.json created")
          PY

      - name: Install required Python packages
        shell: bash
        run: |
          pip3 install PyJWT cryptography requests --break-system-packages

      # ============================================================
      # 9) Setup Beta Localization + Review Info (Required external)
      # ============================================================
      - name: Setup Beta App Localizations & Review Info (Required for External)
        shell: bash
        run: |
          set -euo pipefail

          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"

          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "${BETA_APP_DESCRIPTION}" "${BETA_FEEDBACK_EMAIL}" "${BETA_CONTACT_PHONE}" <<'PY'
          import json, jwt, time, requests, sys

          api_key = json.load(open(sys.argv[1]))
          bundle_id = sys.argv[2]
          beta_description = sys.argv[3]
          feedback_email = sys.argv[4]
          contact_phone = sys.argv[5]

          def token():
            return jwt.encode({
              "iss": api_key["issuer_id"],
              "iat": int(time.time()),
              "exp": int(time.time()) + 1200,
              "aud": "appstoreconnect-v1"
            }, api_key["key"], algorithm="ES256",
            headers={"kid": api_key["key_id"], "typ": "JWT"})

          def h():
            return {"Authorization": f"Bearer {token()}", "Content-Type":"application/json"}

          # Find app
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}", headers=h())
          r.raise_for_status()
          apps = r.json()["data"]
          if not apps:
            raise SystemExit("‚ùå App not found for bundleId")
          app_id = apps[0]["id"]
          print("‚úÖ App:", app_id)

          # Beta App Localization (en-US)
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations?filter[app]={app_id}&filter[locale]=en-US", headers=h())
          r.raise_for_status()
          existing = r.json()["data"]

          attrs = {"feedbackEmail": feedback_email, "description": beta_description}
          if existing:
            loc_id = existing[0]["id"]
            r2 = requests.patch(f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations/{loc_id}", headers=h(),
              json={"data":{"type":"betaAppLocalizations","id":loc_id,"attributes":attrs}})
            print("‚úÖ Beta localization updated" if r2.status_code==200 else f"‚ö†Ô∏è Beta localization update {r2.status_code}")
          else:
            r2 = requests.post("https://api.appstoreconnect.apple.com/v1/betaAppLocalizations", headers=h(),
              json={"data":{"type":"betaAppLocalizations","attributes":{"locale":"en-US",**attrs},"relationships":{"app":{"data":{"type":"apps","id":app_id}}}}})
            print("‚úÖ Beta localization created" if r2.status_code in (200,201) else f"‚ö†Ô∏è Beta localization create {r2.status_code}")

          # Beta Review Detail
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/apps/{app_id}/betaAppReviewDetail", headers=h())
          first="Beta"; last="Contact"
          if feedback_email and "@" in feedback_email:
            base=feedback_email.split("@")[0].replace("_",".")
            parts=base.split(".")
            first=parts[0].capitalize() if parts else "Beta"
            last=parts[1].capitalize() if len(parts)>1 else "Contact"

          review_attrs = {
            "contactEmail": feedback_email,
            "contactFirstName": first,
            "contactLastName": last,
            "contactPhone": contact_phone,
            "demoAccountRequired": False
          }

          if r.status_code==200:
            detail_id=r.json()["data"]["id"]
            r2=requests.patch(f"https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails/{detail_id}", headers=h(),
              json={"data":{"type":"betaAppReviewDetails","id":detail_id,"attributes":review_attrs}})
            print("‚úÖ Beta review detail updated" if r2.status_code==200 else f"‚ö†Ô∏è Beta review update {r2.status_code}")
          else:
            r2=requests.post("https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails", headers=h(),
              json={"data":{"type":"betaAppReviewDetails","attributes":review_attrs,"relationships":{"app":{"data":{"type":"apps","id":app_id}}}}})
            print("‚úÖ Beta review detail created" if r2.status_code in (200,201) else f"‚ö†Ô∏è Beta review create {r2.status_code}")
          PY

      # ============================================================
      # 10) Provisioning profile (fastlane sigh)
      # ============================================================
      - name: Ensure App ID exists (produce)
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"

          fastlane run produce \
            app_identifier:"$BUNDLE_ID" \
            team_id:"${IOS_TEAM_ID}" \
            api_key_path:"$GITHUB_WORKSPACE/.private/api_key.json" \
            skip_itc:true \
            language:en \
            app_name:"Runner" || true

      - name: Get provisioning profile (sigh)
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILE_DIR"

          fastlane run sigh \
            app_identifier:"$BUNDLE_ID" \
            team_id:"${IOS_TEAM_ID}" \
            api_key_path:"$GITHUB_WORKSPACE/.private/api_key.json" \
            provisioning_name:"B4A_${BUNDLE_ID}_APPSTORE" \
            readonly:false \
            output_path:"$PROFILE_DIR"

      - name: Detect provisioning profile name
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          APP_ID="${IOS_TEAM_ID}.${BUNDLE_ID}"
          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"

          FOUND_NAME=""
          for f in "$PROFILES_DIR"/*.mobileprovision; do
            [ -f "$f" ] || continue
            TMP_PLIST="$(mktemp /tmp/profile.XXXXXX.plist)"
            /usr/bin/security cms -D -i "$f" > "$TMP_PLIST" 2>/dev/null || { rm -f "$TMP_PLIST"; continue; }
            P_NAME=$("/usr/libexec/PlistBuddy" -c "Print :Name" "$TMP_PLIST" 2>/dev/null || echo "")
            P_APPID=$("/usr/libexec/PlistBuddy" -c "Print :Entitlements:application-identifier" "$TMP_PLIST" 2>/dev/null || echo "")
            if [ "$P_APPID" = "$APP_ID" ] || [ "$P_APPID" = "${IOS_TEAM_ID}.*" ] || echo "$P_APPID" | grep -q "$BUNDLE_ID"; then
              FOUND_NAME="$P_NAME"
              echo "$FOUND_NAME" > ci_profile_name.txt
              rm -f "$TMP_PLIST"
              break
            fi
            rm -f "$TMP_PLIST"
          done

          [ -n "$FOUND_NAME" ] || { echo "‚ùå No provisioning profile matched"; exit 1; }
          echo "‚úÖ Profile: $FOUND_NAME"

      - name: Create ExportOptions.plist
        shell: bash
        run: |
          set -euo pipefail
          METHOD="${IOS_EXPORT_METHOD:-app-store}"
          TEAM="${IOS_TEAM_ID}"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          PROFILE_NAME="$(tr -d '\r\n' < ci_profile_name.txt)"

          cat > ios/ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>${METHOD}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>teamID</key>
            <string>${TEAM}</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key>
              <string>${PROFILE_NAME}</string>
            </dict>
            <key>destination</key>
            <string>export</string>
            <key>compileBitcode</key>
            <false/>
          </dict>
          </plist>
          EOF

          /usr/bin/plutil -lint ios/ExportOptions.plist

      - name: Patch Runner signing (Release)
        shell: bash
        run: |
          set -euo pipefail
          gem install xcodeproj -N
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          PROFILE_NAME="$(tr -d '\r\n' < ci_profile_name.txt)"
          TEAM_ID="${IOS_TEAM_ID}"

          cat > patch_runner_signing.rb <<'RUBY'
          require "xcodeproj"
          bundle_id = ENV.fetch("BUNDLE_ID")
          profile   = ENV.fetch("PROFILE_NAME")
          team_id   = ENV.fetch("TEAM_ID")

          proj_path = "ios/Runner.xcodeproj"
          project = Xcodeproj::Project.open(proj_path)
          runner = project.targets.find { |t| t.name == "Runner" }
          raise "Runner target not found" unless runner

          runner.build_configurations.each do |cfg|
            next unless cfg.name == "Release"
            s = cfg.build_settings
            s["PRODUCT_BUNDLE_IDENTIFIER"] = bundle_id
            s["CODE_SIGN_STYLE"] = "Manual"
            s["DEVELOPMENT_TEAM"] = team_id
            s["CODE_SIGN_IDENTITY"] = "Apple Distribution"
            s["PROVISIONING_PROFILE_SPECIFIER"] = profile
            s["CODE_SIGNING_ALLOWED"] = "YES"
            s["CODE_SIGNING_REQUIRED"] = "YES"
          end

          project.save
          RUBY

          BUNDLE_ID="$BUNDLE_ID" PROFILE_NAME="$PROFILE_NAME" TEAM_ID="$TEAM_ID" ruby patch_runner_signing.rb

      - name: Build iOS (no codesign in flutter step)
        shell: bash
        run: |
          set -euo pipefail
          flutter build ios --release --no-codesign \
            --dart-define-from-file=lib/env/ci_env.json

      - name: Force Pods = no signing
        shell: bash
        run: |
          set -euo pipefail
          PODS_PBX="ios/Pods/Pods.xcodeproj/project.pbxproj"
          perl -pi -e 's/(PROVISIONING_PROFILE_SPECIFIER(\[sdk=iphoneos\*\])?) = [^;]*;/\1 = "";/g' "$PODS_PBX"
          perl -pi -e 's/PROVISIONING_PROFILE = [^;]*;/PROVISIONING_PROFILE = "";/g' "$PODS_PBX"
          perl -pi -e 's/DEVELOPMENT_TEAM = [A-Z0-9]+;/DEVELOPMENT_TEAM = "";/g' "$PODS_PBX"
          perl -pi -e 's/(CODE_SIGN_IDENTITY(\[sdk=iphoneos\*\])?) = [^;]*;/\1 = "";/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGNING_ALLOWED = YES;/CODE_SIGNING_ALLOWED = NO;/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGNING_REQUIRED = YES;/CODE_SIGNING_REQUIRED = NO;/g' "$PODS_PBX"

      - name: Archive
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/archive
          cd ios

          xcodebuild \
            -workspace Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            archive

      - name: Export IPA
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/ipa
          cd ios

          xcodebuild -exportArchive \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath ../build/ios/ipa \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa
          path: build/ios/ipa/**/*.ipa
          if-no-files-found: error

      # ============================================================
      # 11) Upload to TestFlight + auto submit
      # ============================================================
      - name: Upload to TestFlight (AUTO SUBMIT external review)
        shell: bash
        run: |
          set -euo pipefail
          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          IPA_PATH="$(find "$GITHUB_WORKSPACE/build/ios/ipa" -type f -name "*.ipa" | head -n 1)"

          echo "üì§ Uploading to TestFlight..."
          echo "Bundle: $BUNDLE_ID"
          echo "IPA: $IPA_PATH"

          # Important flags:
          # --distribute_external true   => enable external distribution
          # --skip_submission false      => auto submit for beta review
          # --skip_waiting_for_build_processing false => wait processing
          fastlane pilot upload \
            --ipa "$IPA_PATH" \
            --api_key_path "$API_KEY_JSON" \
            --app_identifier "$BUNDLE_ID" \
            --skip_waiting_for_build_processing false \
            --distribute_external true \
            --skip_submission false \
            --changelog "Automated beta build"

          echo "‚úÖ Upload done. Submitted for external beta review."

      # ============================================================
      # 12) External group + PUBLIC LINK + add build (dynamic)
      # ============================================================
      - name: üöÄ External TestFlight Setup (Public Link + Add build to group)
        shell: bash
        run: |
          set -euo pipefail

          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          APP_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")"

          echo '${{ toJson(github.event.client_payload) }}' > /tmp/ci_payload.json

          python3 - <<'PY' > /tmp/owner_env.sh
          import json, shlex
          p = json.load(open("/tmp/ci_payload.json"))
          cfg = p.get("CONFIG") or {}
          owner_email = (cfg.get("ownerEmail") or p.get("ownerEmail") or "").strip()
          owner_name  = (cfg.get("ownerName") or p.get("ownerName") or "Owner").strip() or "Owner"
          print("OWNER_EMAIL=" + shlex.quote(owner_email))
          print("OWNER_NAME="  + shlex.quote(owner_name))
          PY

          source /tmp/owner_env.sh || true

          echo "üì± App: $APP_NAME"
          echo "üÜî Bundle: $BUNDLE_ID"
          echo "üìß Owner email: ${OWNER_EMAIL:-<none>}"
          echo ""

          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "${OWNER_EMAIL:-}" "${OWNER_NAME:-Owner}" "$APP_NAME" <<'PY'
          import json, jwt, time, requests, sys

          api_key = json.load(open(sys.argv[1]))
          bundle_id = sys.argv[2]
          owner_email = sys.argv[3].strip()
          owner_name = sys.argv[4].strip() or "Owner"
          app_name = sys.argv[5]

          def token():
            return jwt.encode({
              "iss": api_key["issuer_id"],
              "iat": int(time.time()),
              "exp": int(time.time()) + 1200,
              "aud": "appstoreconnect-v1"
            }, api_key["key"], algorithm="ES256",
            headers={"kid": api_key["key_id"], "typ": "JWT"})

          def h():
            return {"Authorization": f"Bearer {token()}", "Content-Type":"application/json"}

          print("="*70)
          print("üöÄ EXTERNAL TESTFLIGHT SETUP (PUBLIC LINK)")
          print("="*70)

          # 1) Find app
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}", headers=h())
          r.raise_for_status()
          apps = r.json()["data"]
          if not apps:
            raise SystemExit(f"‚ùå App not found for bundleId {bundle_id}")
          app_id = apps[0]["id"]
          print("‚úÖ App ID:", app_id)

          # 2) Find/create external group
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaGroups?filter[app]={app_id}&filter[isInternalGroup]=false", headers=h())
          r.raise_for_status()
          groups = r.json()["data"]

          group_id=None
          group_name=None
          public_enabled=False

          # prefer a group that already has public link enabled
          for g in groups:
            attrs = g.get("attributes",{})
            if attrs.get("publicLinkEnabled"):
              group_id=g["id"]
              group_name=attrs.get("name")
              public_enabled=True
              break

          if not group_id and groups:
            group_id=groups[0]["id"]
            group_name=groups[0].get("attributes",{}).get("name","External Testers")
            public_enabled=groups[0].get("attributes",{}).get("publicLinkEnabled",False)

          if not group_id:
            print("‚öôÔ∏è Creating External Testers group...")
            r = requests.post("https://api.appstoreconnect.apple.com/v1/betaGroups", headers=h(), json={
              "data":{
                "type":"betaGroups",
                "attributes":{
                  "name":"External Testers",
                  "isInternalGroup": False,
                  "publicLinkEnabled": True,
                  "publicLinkLimitEnabled": False
                },
                "relationships":{"app":{"data":{"type":"apps","id":app_id}}}
              }
            })
            r.raise_for_status()
            group_id=r.json()["data"]["id"]
            group_name=r.json()["data"]["attributes"]["name"]
            public_enabled=True
            print(f"‚úÖ Created group: {group_name} ({group_id})")
          else:
            print(f"‚úÖ Using group: {group_name} ({group_id})")

          # 3) Ensure public link enabled
          if not public_enabled:
            print("üîß Enabling public link on group...")
            r = requests.patch(f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}", headers=h(), json={
              "data":{"type":"betaGroups","id":group_id,"attributes":{"publicLinkEnabled": True, "publicLinkLimitEnabled": False}}
            })
            if r.status_code==200:
              print("‚úÖ Public link enabled")
            else:
              print("‚ö†Ô∏è Public link enable returned:", r.status_code, r.text[:200])

          # 4) Fetch public link
          public_link = None
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}", headers=h())
          if r.status_code==200:
            attrs=r.json()["data"].get("attributes",{})
            public_link = attrs.get("publicLink")

          if public_link:
            print("üîó PUBLIC LINK:", public_link)
          else:
            print("‚ö†Ô∏è Public link not returned yet (Apple sometimes delays it).")

          # 5) Find latest build (wait until VALID)
          build_id=None
          version=None
          build_num=None

          for i in range(20):
            r = requests.get(f"https://api.appstoreconnect.apple.com/v1/builds?filter[app]={app_id}&sort=-uploadedDate&limit=1", headers=h())
            r.raise_for_status()
            builds=r.json()["data"]
            if builds:
              b=builds[0]
              build_id=b["id"]
              version=b.get("attributes",{}).get("version")
              build_num=b.get("attributes",{}).get("buildNumber","")
              state=b.get("attributes",{}).get("processingState","PROCESSING")
              if state=="VALID":
                print(f"‚úÖ Build ready: {version} ({build_num})")
                break
              print(f"‚è≥ Build processing: {version} state={state} (attempt {i+1}/20)")
            else:
              print(f"‚è≥ No build yet (attempt {i+1}/20)")
            time.sleep(30)

          if not build_id:
            print("‚ö†Ô∏è No build available yet, stopping group attach.")
            sys.exit(0)

          # 6) Export compliance
          r = requests.patch(f"https://api.appstoreconnect.apple.com/v1/builds/{build_id}", headers=h(), json={
            "data":{"type":"builds","id":build_id,"attributes":{"usesNonExemptEncryption": False}}
          })
          if r.status_code==200:
            print("‚úÖ Export compliance set")
          elif r.status_code==409:
            print("‚úÖ Export compliance already set")
          else:
            print("‚ÑπÔ∏è Export compliance:", r.status_code)

          # 7) Attach build to group
          r = requests.post(f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/builds", headers=h(), json={
            "data":[{"type":"builds","id":build_id}]
          })
          if r.status_code in (200,204):
            print("‚úÖ Build added to external group")
          elif r.status_code==409:
            print("‚úÖ Build already in group")
          else:
            print("‚ö†Ô∏è Add build to group:", r.status_code, r.text[:200])

          # 8) Optional: add specific tester by email if provided (not required for public link)
          if owner_email:
            print("üë§ Ensuring tester exists + add to group:", owner_email)
            tester_id=None
            r = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaTesters?filter[email]={owner_email}", headers=h())
            if r.status_code==200 and r.json().get("data"):
              tester_id=r.json()["data"][0]["id"]

            if not tester_id:
              first = owner_name.split()[0] if owner_name else "Owner"
              last = " ".join(owner_name.split()[1:]) if len(owner_name.split())>1 else ""
              r = requests.post("https://api.appstoreconnect.apple.com/v1/betaTesters", headers=h(), json={
                "data":{"type":"betaTesters","attributes":{"email":owner_email,"firstName":first,"lastName":last}}
              })
              if r.status_code in (200,201):
                tester_id=r.json()["data"]["id"]

            if tester_id:
              r = requests.post(f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/betaTesters", headers=h(),
                json={"data":[{"type":"betaTesters","id":tester_id}]})
              if r.status_code in (200,204):
                print("‚úÖ Tester added")
              elif r.status_code==409:
                print("‚úÖ Tester already in group")
              else:
                print("‚ö†Ô∏è Add tester:", r.status_code, r.text[:200])

          print("="*70)
          print("‚úÖ DONE: External group + public link + build attached")
          print("‚è≥ Note: External builds still need Apple Beta Review approval.")
          print("="*70)
          PY
