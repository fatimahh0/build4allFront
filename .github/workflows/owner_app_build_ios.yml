name: Owner App Build (iOS) - External Testing Auto

on:
  repository_dispatch:
    types: [owner_app_build_ios]

permissions:
  contents: write

jobs:
  build-ios:
    runs-on: macos-15

    env:
      CI_CALLBACK_TOKEN: ${{ secrets.CI_CALLBACK_TOKEN }}
      CI_RUNTIME_TOKEN: ${{ secrets.CI_RUNTIME_TOKEN }}

      IOS_P12_B64: ${{ secrets.IOS_P12_B64 }}
      IOS_P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
      IOS_TEAM_ID: ${{ secrets.IOS_TEAM_ID }}
      IOS_EXPORT_METHOD: ${{ secrets.IOS_EXPORT_METHOD }}

      ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
      ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
      ASC_KEY_P8_B64: ${{ secrets.ASC_KEY_P8_B64 }}

      DEFAULT_BETA_APP_DESCRIPTION: ${{ secrets.DEFAULT_BETA_APP_DESCRIPTION }}
      DEFAULT_BETA_FEEDBACK_EMAIL: ${{ secrets.DEFAULT_BETA_FEEDBACK_EMAIL }}
      DEFAULT_BETA_CONTACT_PHONE: ${{ secrets.DEFAULT_BETA_CONTACT_PHONE }}

      SPACESHIP_CONNECT_API_IN_HOUSE: "false"
      COCOAPODS_DISABLE_STATS: "true"
      FASTLANE_OPT_OUT_USAGE: "true"
      LANG: en_US.UTF-8
      LC_ALL: en_US.UTF-8

    steps:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # CHECKOUT & TOOLING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select newest installed Xcode (safe)
        shell: bash
        run: |
          set -euo pipefail
      
          echo "ğŸ” Installed Xcodes:"
          ls -1 /Applications | grep -E '^Xcode.*\.app$' || true
      
          XCODE_APP="$(ls -1 /Applications | grep -E '^Xcode.*\.app$' | sort -V | tail -n 1)"
      
          if [ -z "${XCODE_APP:-}" ]; then
            echo "âŒ No Xcode found in /Applications"
            exit 1
          fi
      
          echo "âœ… Selected: $XCODE_APP"
          sudo xcode-select -s "/Applications/$XCODE_APP/Contents/Developer"
      
          xcodebuild -version
          echo "iOS SDK: $(xcrun --sdk iphoneos --show-sdk-version)"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.32.0"
          channel: stable
          cache: true

      - name: Flutter pub get
        shell: bash
        run: |
          set -euo pipefail
          flutter --version
          flutter pub get

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # RUNTIME CONFIG
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Show dispatch payload (debug)
        shell: bash
        run: |
          set -euo pipefail
          echo '${{ toJson(github.event.client_payload) }}'

      - name: Build ci_env.json (BY_LINK runtime-config + fallback + B64)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p lib/env

          python3 - <<'PY'
          import json, os, urllib.request, urllib.error, socket, re

          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          api_base = (cfg.get("API_BASE_URL") or payload.get("API_BASE_URL") or "").rstrip("/")
          link_id = str(
              cfg.get("OWNER_PROJECT_LINK_ID")
              or payload.get("OWNER_PROJECT_LINK_ID")
              or payload.get("ownerProjectLinkId")
              or cfg.get("ownerProjectLinkId")
              or ""
          ).strip()

          if not api_base:
              raise SystemExit("Missing API_BASE_URL")
          if not link_id:
              raise SystemExit("Missing OWNER_PROJECT_LINK_ID")

          url = f"{api_base}/api/public/runtime-config/by-link?linkId={link_id}"
          runtime = {}
          source = "FALLBACK (payload/defaults)"

          token = (os.getenv("CI_RUNTIME_TOKEN") or "").strip()
          headers = {"Accept": "application/json"}
          if token:
              headers["X-Auth-Token"] = token

          try:
              print("Fetching runtime config:", url)
              print("Auth header present =", "YES" if token else "NO")
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=12) as r:
                  raw = r.read().decode("utf-8")
                  runtime = json.loads(raw)
              source = "BY_LINK"
          except (urllib.error.HTTPError, urllib.error.URLError, socket.timeout, json.JSONDecodeError) as e:
              print("âš ï¸ runtime-config fetch failed, using fallback:", repr(e))

          print("CONFIG SOURCE =", source)

          def pick(key, default=None):
              v = runtime.get(key)
              if v not in (None, "", []):
                  return v
              v = cfg.get(key)
              if v not in (None, "", []):
                  return v
              v = payload.get(key)
              if v not in (None, "", []):
                  return v
              return default

          app_name = pick("APP_NAME", "My App")
          app_type = pick("APP_TYPE", "ECOMMERCE")
          project_id = str(pick("PROJECT_ID", "")).strip()

          ios_bundle = (
              pick("iosBundleId") or 
              pick("IOS_BUNDLE_ID") or 
              pick("PACKAGE_NAME") or 
              pick("APPLICATION_ID") or 
              ""
          ).strip()

          if not ios_bundle:
              ios_bundle = f"com.build4all.app{link_id}"
          
          ios_bundle = ios_bundle.lower()
          ios_bundle = re.sub(r"[^a-z0-9._]", "", ios_bundle)
          ios_bundle = re.sub(r"\.+", ".", ios_bundle).strip(".")
          
          if not ios_bundle or ios_bundle.count(".") < 1:
              ios_bundle = f"com.build4all.app{link_id}"

          vc = pick("IOS_BUILD_NUMBER") or pick("iosBuildNumber") or pick("ANDROID_VERSION_CODE")
          vn = pick("IOS_VERSION_NAME") or pick("iosVersionName") or pick("ANDROID_VERSION_NAME")

          try:
              vc_int = int(vc) if vc not in (None,"",[]) else None
          except Exception:
              vc_int = None

          vn_str = (str(vn).strip() if vn not in (None,"",[]) else "")

          env = {
              "API_BASE_URL": api_base,
              "APP_NAME": app_name,
              "APP_TYPE": app_type,
              "OWNER_PROJECT_LINK_ID": link_id,
              "PROJECT_ID": project_id,
              "IOS_BUNDLE_ID": ios_bundle,
              "IOS_BUILD_NUMBER": vc_int if vc_int is not None else 1,
              "IOS_VERSION_NAME": vn_str if vn_str else "1.0.0",
              "CONFIG_SOURCE": source,
          }

          currency_id = pick("CURRENCY_ID")
          if currency_id in (None, "", []):
              currency_id = (
                  runtime.get("currencyId")
                  or cfg.get("currencyId")
                  or payload.get("currencyId")
              )
          if currency_id not in (None, "", []):
              env["CURRENCY_ID"] = str(currency_id).strip()

          for key in [
              "THEME_JSON_B64",
              "NAV_JSON_B64",
              "HOME_JSON_B64",
              "ENABLED_FEATURES_JSON_B64",
              "BRANDING_JSON_B64",
          ]:
              v = pick(key)
              if v:
                  env[key] = v

          logo_url = (pick("LOGO_URL") or pick("LOGO_PATH") or "").strip()
          if not logo_url:
              logo_url = (runtime.get("logoUrl") or cfg.get("logoUrl") or payload.get("logoUrl") or "").strip()
          if logo_url:
              env["LOGO_URL"] = logo_url

          open("ci_api_base.txt", "w", encoding="utf-8").write(api_base)
          open("ci_link_id.txt", "w", encoding="utf-8").write(link_id)
          open("ci_ios_bundle_id.txt", "w", encoding="utf-8").write(ios_bundle)

          with open("lib/env/ci_env.json", "w", encoding="utf-8") as f:
              json.dump(env, f, ensure_ascii=False, indent=2)

          print("âœ… ci_env.json written")
          print("API_BASE_URL =", api_base)
          print("OWNER_PROJECT_LINK_ID =", link_id)
          print("PROJECT_ID =", project_id)
          print("IOS_BUNDLE_ID =", ios_bundle)
          print("IOS_BUILD_NUMBER =", env["IOS_BUILD_NUMBER"])
          print("IOS_VERSION_NAME =", env["IOS_VERSION_NAME"])
          print("CURRENCY_ID =", env.get("CURRENCY_ID"))
          print("CONFIG_SOURCE =", source)
          print("LOGO_URL =", env.get("LOGO_URL"))

          for k in ["THEME_JSON_B64","NAV_JSON_B64","HOME_JSON_B64","ENABLED_FEATURES_JSON_B64","BRANDING_JSON_B64"]:
              print(k, "=", "YES" if env.get(k) else "NO")
          PY

      - name: Debug env
        shell: bash
        run: |
          echo "----- ci_env.json -----"
          cat lib/env/ci_env.json

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # ğŸ” DEMO ACCOUNT â€“ calls BOTH endpoints, parses real credentials
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ” Create Demo Account for Apple Review (this app)
        shell: bash
        run: |
          set -euo pipefail

          API_BASE="$(cat ci_api_base.txt)"
          LINK_ID="$(cat ci_link_id.txt)"

          echo "ğŸ” Creating demo account for this appâ€¦"
          echo "   API:     $API_BASE"
          echo "   Link ID: $LINK_ID"
          echo ""

          RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST \
            "$API_BASE/api/auth/demo/create-apple-review-account?ownerProjectLinkId=$LINK_ID" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Token: ${{ secrets.CI_RUNTIME_TOKEN }}" \
            2>&1)

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP $HTTP_CODE"
          echo "$BODY" | python3 -m json.tool 2>/dev/null || echo "$BODY"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "âš ï¸  Single-app demo account creation returned HTTP $HTTP_CODE"
            echo "    Continuing â€“ seed-all step will run next."
          fi

          # â”€â”€ Parse email + password from the response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Falls back to the hard-coded defaults that the Java endpoint itself uses.
          DEMO_EMAIL=$(echo "$BODY" | python3 -c "
          import sys, json
          try:
              print(json.load(sys.stdin).get('email',''))
          except:
              print('')
          " 2>/dev/null || echo "")

          DEMO_PASSWORD=$(echo "$BODY" | python3 -c "
          import sys, json
          try:
              print(json.load(sys.stdin).get('password',''))
          except:
              print('')
          " 2>/dev/null || echo "")

          # Fall back to the same defaults the Java endpoint uses
          [ -n "$DEMO_EMAIL"    ] || DEMO_EMAIL="demo@applereview.com"
          [ -n "$DEMO_PASSWORD" ] || DEMO_PASSWORD="AppleReview2026!"

          # â”€â”€ Export to GITHUB_ENV so every later step can read them â”€â”€â”€â”€â”€
          echo "DEMO_EMAIL=$DEMO_EMAIL"       >> "$GITHUB_ENV"
          echo "DEMO_PASSWORD=$DEMO_PASSWORD" >> "$GITHUB_ENV"

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "        ğŸ” DEMO CREDENTIALS (parsed from endpoint)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "   ğŸ“§ Email:    $DEMO_EMAIL"
          echo "   ğŸ”‘ Password: $DEMO_PASSWORD"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: ğŸ” Seed Demo Account across all apps
        shell: bash
        run: |
          set -euo pipefail

          API_BASE="$(cat ci_api_base.txt)"

          echo "ğŸ” Seeding demo account for every appâ€¦"
          echo "   API: $API_BASE"
          echo ""

          RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST \
            "$API_BASE/api/auth/demo/seed-apple-review-account-all" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Token: ${{ secrets.CI_RUNTIME_TOKEN }}" \
            2>&1)

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP $HTTP_CODE"
          echo "$BODY" | python3 -m json.tool 2>/dev/null || echo "$BODY"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "âš ï¸  seed-all returned HTTP $HTTP_CODE â€“ continuing anyway"
          else
            echo "âœ… All apps seeded"
          fi

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # APP STORE CONNECT METADATA
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Read App Store Connect metadata
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os
          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          def pick(*keys):
            for k in keys:
              if k in payload and payload[k]:
                return payload[k]
              if k in cfg and cfg[k]:
                return cfg[k]
            return ""

          app_name = pick("APPLE_APP_NAME","appleAppName","appStoreAppName","ASC_APP_NAME")
          sku      = pick("APPLE_SKU","appleSku","appStoreSku","ASC_SKU")
          locale   = pick("APPLE_PRIMARY_LOCALE","applePrimaryLocale","primaryLocale","ASC_PRIMARY_LOCALE") or "en-US"
          
          beta_description = (
              pick("BETA_APP_DESCRIPTION","betaAppDescription") 
              or os.environ.get("DEFAULT_BETA_APP_DESCRIPTION", "")
              or "Test our app and provide feedback on features, usability, and overall experience."
          )
          
          feedback_email = (
              pick("BETA_FEEDBACK_EMAIL","betaFeedbackEmail","ownerEmail")
              or os.environ.get("DEFAULT_BETA_FEEDBACK_EMAIL", "")
              or pick("ownerEmail")
              or ""
          )
          
          contact_phone = (
              pick("BETA_CONTACT_PHONE","betaContactPhone")
              or os.environ.get("DEFAULT_BETA_CONTACT_PHONE", "")
              or "+1234567890"
          )
          
          marketing_url = pick("MARKETING_URL","marketingUrl") or ""
          privacy_url = pick("PRIVACY_POLICY_URL","privacyPolicyUrl") or ""

          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write(f"APPLE_APP_NAME={app_name}\n")
            f.write(f"APPLE_SKU={sku}\n")
            f.write(f"APPLE_PRIMARY_LOCALE={locale}\n")
            f.write(f"BETA_APP_DESCRIPTION={beta_description}\n")
            f.write(f"BETA_FEEDBACK_EMAIL={feedback_email}\n")
            f.write(f"BETA_CONTACT_PHONE={contact_phone}\n")
            f.write(f"MARKETING_URL={marketing_url}\n")
            f.write(f"PRIVACY_POLICY_URL={privacy_url}\n")

          print("APPLE_APP_NAME=", app_name)
          print("APPLE_SKU=", sku)
          print("APPLE_PRIMARY_LOCALE=", locale)
          print("BETA_APP_DESCRIPTION=", beta_description[:100] + "..." if len(beta_description) > 100 else beta_description)
          print("BETA_FEEDBACK_EMAIL=", feedback_email)
          print("BETA_CONTACT_PHONE=", contact_phone)
          print("MARKETING_URL=", marketing_url)
          print("PRIVACY_POLICY_URL=", privacy_url)
          PY

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # FLUTTER / iOS PROJECT SETUP
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Ensure iOS Podfile exists
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f "ios/Podfile" ]; then
            flutter create .
          fi
          test -f ios/Podfile

      - name: Set iOS version & build number
        shell: bash
        run: |
          set -euo pipefail
          
          python3 - <<'PY'
          import json, re
          
          cfg = json.load(open("lib/env/ci_env.json"))
          
          version_name = cfg.get("IOS_VERSION_NAME", "1.0.0")
          build_number = cfg.get("IOS_BUILD_NUMBER", 1)
          
          version_name = str(version_name).strip()
          build_number = str(build_number).strip()
          
          print(f"iOS Version: {version_name}")
          print(f"iOS Build Number: {build_number}")
          
          info_plist = "ios/Runner/Info.plist"
          with open(info_plist, "r", encoding="utf-8") as f:
              content = f.read()
          
          content = re.sub(
              r"(<key>CFBundleShortVersionString</key>\s*<string>)[^<]*(</string>)",
              rf"\g<1>{version_name}\g<2>",
              content
          )
          
          content = re.sub(
              r"(<key>CFBundleVersion</key>\s*<string>)[^<]*(</string>)",
              rf"\g<1>{build_number}\g<2>",
              content
          )
          
          with open(info_plist, "w", encoding="utf-8") as f:
              f.write(content)
          
          print(f"âœ… Updated {info_plist}")
          PY

      - name: Add privacy strings to Info.plist
        shell: bash
        run: |
          set -euo pipefail
          
          INFO_PLIST="ios/Runner/Info.plist"
          
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs access to your photo library to allow you to select and upload images.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'This app needs access to your photo library to allow you to select and upload images.'" "$INFO_PLIST"
          
          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs access to your camera to allow you to take and upload photos.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'This app needs access to your camera to allow you to take and upload photos.'" "$INFO_PLIST"
          
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save images to your photo library.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'This app needs permission to save images to your photo library.'" "$INFO_PLIST"
          
          echo "âœ… Privacy strings added"

      - name: Apply branding (logo + app name)
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json, urllib.request, pathlib, shutil

          cfg = json.load(open("lib/env/ci_env.json","r",encoding="utf-8"))

          app_name_raw = cfg.get("APP_NAME","My App")
          api_base = (cfg.get("API_BASE_URL") or "").rstrip("/")
          logo_url = (cfg.get("LOGO_URL") or "").strip()

          print("APP_NAME:", app_name_raw)
          print("LOGO_URL (raw):", logo_url)
          print("API_BASE_URL:", api_base)

          pathlib.Path("assets/branding").mkdir(parents=True, exist_ok=True)

          if logo_url and logo_url.startswith("/") and api_base:
              logo_url = api_base + logo_url
              print("Resolved absolute LOGO_URL:", logo_url)

          if logo_url:
              try:
                  print("Downloading logo from:", logo_url)
                  urllib.request.urlretrieve(logo_url, "assets/branding/logo.png")
                  shutil.copyfile("assets/branding/logo.png","assets/branding/launcher.png")
                  shutil.copyfile("assets/branding/logo.png","assets/branding/splash.png")
                  print("âœ… Logo downloaded successfully")
              except Exception as e:
                  print("âš ï¸ Failed to download logo:", e)
                  print("Continuing without custom logo...")
          else:
              print("âš ï¸ No LOGO_URL provided, skipping logo download")
          PY

          flutter pub get
          flutter pub run flutter_launcher_icons || echo "âš ï¸ flutter_launcher_icons failed"
          flutter pub run flutter_native_splash:create || echo "âš ï¸ flutter_native_splash failed"

      - name: Set iOS App Name in Info.plist
        shell: bash
        run: |
          set -euo pipefail
          
          INFO_PLIST="ios/Runner/Info.plist"
          APP_NAME=$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")
          
          echo "Setting iOS App Name to: $APP_NAME"
          
          /usr/libexec/PlistBuddy -c "Add :CFBundleDisplayName string '$APP_NAME'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName '$APP_NAME'" "$INFO_PLIST"
          
          /usr/libexec/PlistBuddy -c "Set :CFBundleName '$APP_NAME'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :CFBundleName string '$APP_NAME'" "$INFO_PLIST"
          
          echo "âœ… iOS App Name set"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # CODE SIGNING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Setup iOS signing certificate
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${IOS_P12_B64:-}" ] || { echo "âŒ Missing IOS_P12_B64"; exit 1; }
          [ -n "${IOS_P12_PASSWORD:-}" ] || { echo "âŒ Missing IOS_P12_PASSWORD"; exit 1; }

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"

          security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db
          security default-keychain -s "$KEYCHAIN_PATH"

          echo "$IOS_P12_B64" | tr -d '\n\r ' | base64 --decode > ios_cert.p12
          security import ios_cert.p12 -k "$KEYCHAIN_PATH" -P "$IOS_P12_PASSWORD" -A \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          CNT=$(security find-identity -v -p codesigning | grep -c "Apple Distribution" || true)
          if [ "$CNT" -lt 1 ]; then
            echo "âŒ Apple Distribution identity not found"
            exit 1
          fi

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"

      - name: Install CocoaPods + fastlane
        shell: bash
        run: |
          set -euo pipefail
          gem install cocoapods -N
          gem install fastlane -N
          pod --version
          fastlane --version

      - name: Clean Pods
        shell: bash
        run: |
          set -euo pipefail
          rm -rf ios/Pods
          rm -f ios/Podfile.lock

      - name: Install iOS Pods
        shell: bash
        run: |
          set -euo pipefail
          cd ios
          pod install || { pod repo update; pod install; }

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # APP STORE CONNECT API KEY
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Create App Store Connect api_key.json
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .private

          [ -n "${ASC_KEY_ID:-}" ] || { echo "âŒ ASC_KEY_ID empty"; exit 1; }
          [ -n "${ASC_ISSUER_ID:-}" ] || { echo "âŒ ASC_ISSUER_ID empty"; exit 1; }
          [ -n "${ASC_KEY_P8_B64:-}" ] || { echo "âŒ ASC_KEY_P8_B64 empty"; exit 1; }

          echo "${ASC_KEY_P8_B64}" | base64 --decode > .private/AuthKey_${ASC_KEY_ID}.p8

          python3 - <<'PY'
          import json, pathlib, os

          key_path = pathlib.Path(f".private/AuthKey_{os.environ['ASC_KEY_ID']}.p8")
          
          try:
              p8_content = key_path.read_text(encoding='utf-8')
          except UnicodeDecodeError:
              try:
                  p8_content = key_path.read_bytes().decode('ascii')
              except:
                  p8_content = key_path.read_bytes().decode('latin-1')
                  print("âš ï¸ Warning: Using latin-1 fallback for key file")

          api_key_data = {
            "key_id": os.environ["ASC_KEY_ID"].strip(),
            "issuer_id": os.environ["ASC_ISSUER_ID"].strip(),
            "key": p8_content,
            "in_house": False
          }

          pathlib.Path(".private/api_key.json").write_text(
              json.dumps(api_key_data, ensure_ascii=False, indent=2)
          )
          
          print("âœ… api_key.json created successfully")
          PY
          
          echo "ğŸ” Verifying key file format..."
          if head -n 1 .private/AuthKey_${ASC_KEY_ID}.p8 | grep -q "BEGIN PRIVATE KEY"; then
            echo "âœ… Key file format looks correct"
          else
            echo "âš ï¸ Warning: Key file might not be in correct format"
            echo "First line:"
            head -n 1 .private/AuthKey_${ASC_KEY_ID}.p8
          fi

      - name: Install required Python packages
        shell: bash
        run: |
          pip3 install PyJWT cryptography requests --break-system-packages

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # BETA APP REVIEW â€“ uses $DEMO_EMAIL / $DEMO_PASSWORD from GITHUB_ENV
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Setup Beta App Review Info with Demo Credentials
        shell: bash
        run: |
          set -euo pipefail
          
          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"

          # DEMO_EMAIL and DEMO_PASSWORD are already exported to GITHUB_ENV
          # by the "Create Demo Account" step â€“ no hardcoding needed here.
          
          echo "ğŸ“‹ Setting up Beta App Review Info with demo credentials..."
          echo "Bundle ID: $BUNDLE_ID"
          echo "Description: ${BETA_APP_DESCRIPTION:0:80}..."
          echo "Feedback Email: ${BETA_FEEDBACK_EMAIL}"
          echo "Contact Phone: ${BETA_CONTACT_PHONE}"
          echo ""
          echo "ğŸ” Demo Account Credentials:"
          echo "   Email: $DEMO_EMAIL"
          echo "   Password: $DEMO_PASSWORD"
          echo ""
          
          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "${BETA_APP_DESCRIPTION}" "${BETA_FEEDBACK_EMAIL}" "${BETA_CONTACT_PHONE}" "$DEMO_EMAIL" "$DEMO_PASSWORD" <<'PYEOF'
          import json, jwt, time, requests, sys
          
          api_key = json.load(open(sys.argv[1]))
          
          def create_token():
              return jwt.encode({
                  'iss': api_key['issuer_id'],
                  'iat': int(time.time()),
                  'exp': int(time.time()) + 1200,
                  'aud': 'appstoreconnect-v1'
              }, api_key['key'], algorithm='ES256',
              headers={'kid': api_key['key_id'], 'typ': 'JWT'})
          
          def h():
              return {
                  "Authorization": f"Bearer {create_token()}",
                  "Content-Type": "application/json"
              }
          
          bundle_id = sys.argv[2]
          beta_description = sys.argv[3]
          feedback_email = sys.argv[4]
          contact_phone = sys.argv[5]
          demo_email = sys.argv[6]
          demo_password = sys.argv[7]
          
          print("1ï¸âƒ£ Finding app in App Store Connect...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}",
              headers=h()
          )
          r.raise_for_status()
          apps = r.json()['data']
          
          if not apps:
              print(f"âŒ App not found: {bundle_id}")
              sys.exit(1)
          
          app_id = apps[0]['id']
          print(f"   âœ… App found: {app_id}")
          print()
          
          print("2ï¸âƒ£ Setting up Beta App Localization...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations?filter[app]={app_id}&filter[locale]=en-US",
              headers=h()
          )
          r.raise_for_status()
          
          localization_data = {
              "feedbackEmail": feedback_email,
              "description": beta_description
          }
          
          existing = r.json()['data']
          
          if existing:
              loc_id = existing[0]['id']
              r2 = requests.patch(
                  f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations/{loc_id}",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaAppLocalizations",
                          "id": loc_id,
                          "attributes": localization_data
                      }
                  }
              )
              
              if r2.status_code == 200:
                  print("   âœ… Beta app localization updated")
              else:
                  print(f"   âš ï¸  Update failed: {r2.status_code}")
          else:
              r2 = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaAppLocalizations",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaAppLocalizations",
                          "attributes": {
                              "locale": "en-US",
                              **localization_data
                          },
                          "relationships": {
                              "app": {"data": {"type": "apps", "id": app_id}}
                          }
                      }
                  }
              )
              
              if r2.status_code in (200, 201):
                  print("   âœ… Beta app localization created")
              else:
                  print(f"   âš ï¸  Creation failed: {r2.status_code}")
          
          print()
          
          print("3ï¸âƒ£ Setting up Beta App Review Detail with demo credentials...")
          try:
              r = requests.get(
                  f"https://api.appstoreconnect.apple.com/v1/apps/{app_id}/betaAppReviewDetail",
                  headers=h()
              )
              
              email_name = feedback_email.split('@')[0] if '@' in feedback_email else "Beta"
              first_name = email_name.split('.')[0].capitalize() if '.' in email_name else email_name.capitalize()
              last_name = email_name.split('.')[1].capitalize() if '.' in email_name and len(email_name.split('.')) > 1 else "Tester"
              
              review_data = {
                  "contactEmail": feedback_email,
                  "contactFirstName": first_name,
                  "contactLastName": last_name,
                  "contactPhone": contact_phone,
                  "demoAccountRequired": True,
                  "demoAccountName": demo_email,
                  "demoAccountPassword": demo_password
              }
              
              if r.status_code == 200:
                  detail_id = r.json()['data']['id']
                  print(f"   Updating existing review detail: {detail_id}")
                  
                  r2 = requests.patch(
                      f"https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails/{detail_id}",
                      headers=h(),
                      json={
                          "data": {
                              "type": "betaAppReviewDetails",
                              "id": detail_id,
                              "attributes": review_data
                          }
                      }
                  )
                  
                  if r2.status_code == 200:
                      print("   âœ… Beta review detail updated with demo credentials")
                      print(f"      Contact: {first_name} {last_name}")
                      print(f"      Email: {feedback_email}")
                      print(f"      Phone: {contact_phone}")
                      print(f"      Demo Account: {demo_email}")
                      print(f"      Demo Password: {'*' * len(demo_password)}")
                  else:
                      print(f"   âš ï¸  Update failed: {r2.status_code}")
                      print(r2.text)
              else:
                  print(f"   Creating new review detail...")
                  
                  r2 = requests.post(
                      "https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails",
                      headers=h(),
                      json={
                          "data": {
                              "type": "betaAppReviewDetails",
                              "attributes": review_data,
                              "relationships": {
                                  "app": {"data": {"type": "apps", "id": app_id}}
                              }
                          }
                      }
                  )
                  
                  if r2.status_code in (200, 201):
                      print("   âœ… Beta review detail created with demo credentials")
                      print(f"      Contact: {first_name} {last_name}")
                      print(f"      Email: {feedback_email}")
                      print(f"      Phone: {contact_phone}")
                      print(f"      Demo Account: {demo_email}")
                      print(f"      Demo Password: {'*' * len(demo_password)}")
                  else:
                      print(f"   âš ï¸  Creation failed: {r2.status_code}")
                      print(r2.text)
                      
          except Exception as e:
              print(f"   âš ï¸  Error: {str(e)[:100]}")
          
          print()
          print("=" * 60)
          print("âœ… Beta metadata setup complete!")
          print("=" * 60)
          print("   ğŸ“‹ Beta App Localization: Configured")
          print("   ğŸ‘¤ Beta Review Contact: Configured")
          print("   ğŸ” Demo Credentials: Configured")
          print("   ğŸ“§ Feedback Email:", feedback_email)
          print("   ğŸ“± Contact Phone:", contact_phone)
          print("   ğŸ”‘ Demo Email:", demo_email)
          print()
          print("ğŸš€ Ready for external testing upload!")
          print("=" * 60)
          PYEOF

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PROVISIONING & EXPORT
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Ensure App ID exists
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(cat ci_ios_bundle_id.txt | tr -d '\r\n')"

          fastlane run produce \
            app_identifier:"$BUNDLE_ID" \
            team_id:"${IOS_TEAM_ID}" \
            api_key_path:"$GITHUB_WORKSPACE/.private/api_key.json" \
            skip_itc:true \
            language:en \
            app_name:"Runner" || true

      - name: Get provisioning profile
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"

          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILE_DIR"

          fastlane run sigh \
            app_identifier:"$BUNDLE_ID" \
            team_id:"${IOS_TEAM_ID}" \
            api_key_path:"$GITHUB_WORKSPACE/.private/api_key.json" \
            provisioning_name:"B4A_${BUNDLE_ID}_APPSTORE" \
            readonly:false \
            output_path:"$PROFILE_DIR"

          sleep 2

      - name: Detect provisioning profile name
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(cat ci_ios_bundle_id.txt | tr -d '\r\n')"
          APP_ID="${IOS_TEAM_ID}.${BUNDLE_ID}"

          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"

          FOUND_NAME=""
          
          for f in "$PROFILES_DIR"/*.mobileprovision; do
            [ -f "$f" ] || continue
            
            TMP_PLIST="$(mktemp /tmp/profile.XXXXXX.plist)"
            /usr/bin/security cms -D -i "$f" > "$TMP_PLIST" 2>/dev/null || {
              rm -f "$TMP_PLIST"
              continue
            }

            P_NAME=$("/usr/libexec/PlistBuddy" -c "Print :Name" "$TMP_PLIST" 2>/dev/null || echo "Unknown")
            P_APPID=$("/usr/libexec/PlistBuddy" -c "Print :Entitlements:application-identifier" "$TMP_PLIST" 2>/dev/null || echo "")
            
            if [ "$P_APPID" = "$APP_ID" ] || [ "$P_APPID" = "${IOS_TEAM_ID}.*" ] || echo "$P_APPID" | grep -q "$BUNDLE_ID"; then
              FOUND_NAME="$P_NAME"
              echo "$FOUND_NAME" > ci_profile_name.txt
              rm -f "$TMP_PLIST"
              break
            fi
            
            rm -f "$TMP_PLIST"
          done

          if [ -z "$FOUND_NAME" ]; then
            echo "âŒ No provisioning profile matched"
            exit 1
          fi

          echo "âœ… Profile: $FOUND_NAME"

      - name: Create ExportOptions.plist
        shell: bash
        run: |
          set -euo pipefail

          METHOD="${IOS_EXPORT_METHOD:-app-store}"
          TEAM="${IOS_TEAM_ID}"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          PROFILE_NAME="$(tr -d '\r\n' < ci_profile_name.txt)"

          cat > ios/ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>${METHOD}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>teamID</key>
            <string>${TEAM}</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key>
              <string>${PROFILE_NAME}</string>
            </dict>
            <key>destination</key>
            <string>export</string>
            <key>compileBitcode</key>
            <false/>
          </dict>
          </plist>
          EOF

          /usr/bin/plutil -lint ios/ExportOptions.plist

      - name: Patch Runner signing
        shell: bash
        run: |
          set -euo pipefail

          gem install xcodeproj -N

          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          PROFILE_NAME="$(tr -d '\r\n' < ci_profile_name.txt)"
          TEAM_ID="${IOS_TEAM_ID}"

          cat > patch_runner_signing.rb <<'RUBY'
          require "xcodeproj"

          bundle_id = ENV.fetch("BUNDLE_ID")
          profile   = ENV.fetch("PROFILE_NAME")
          team_id   = ENV.fetch("TEAM_ID")

          proj_path = "ios/Runner.xcodeproj"
          project = Xcodeproj::Project.open(proj_path)

          runner = project.targets.find { |t| t.name == "Runner" }
          raise "Runner target not found" unless runner

          runner.build_configurations.each do |cfg|
            next unless cfg.name == "Release"
            s = cfg.build_settings

            s["PRODUCT_BUNDLE_IDENTIFIER"] = bundle_id
            s["CODE_SIGN_STYLE"] = "Manual"
            s["DEVELOPMENT_TEAM"] = team_id
            s["CODE_SIGN_IDENTITY"] = "Apple Distribution"
            s["PROVISIONING_PROFILE_SPECIFIER"] = profile
            s["CODE_SIGNING_ALLOWED"] = "YES"
            s["CODE_SIGNING_REQUIRED"] = "YES"
          end

          project.save
          RUBY

          BUNDLE_ID="$BUNDLE_ID" PROFILE_NAME="$PROFILE_NAME" TEAM_ID="$TEAM_ID" ruby patch_runner_signing.rb

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # BUILD, ARCHIVE, EXPORT
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Build iOS
        shell: bash
        run: |
          set -euo pipefail
          flutter build ios --release --no-codesign \
            --dart-define-from-file=lib/env/ci_env.json

      - name: Force Pods = no signing
        shell: bash
        run: |
          set -euo pipefail
          PODS_PBX="ios/Pods/Pods.xcodeproj/project.pbxproj"
          
          perl -pi -e 's/(PROVISIONING_PROFILE_SPECIFIER(\[sdk=iphoneos\*\])?) = [^;]*;/\1 = "";/g' "$PODS_PBX"
          perl -pi -e 's/PROVISIONING_PROFILE = [^;]*;/PROVISIONING_PROFILE = "";/g' "$PODS_PBX"
          perl -pi -e 's/DEVELOPMENT_TEAM = [A-Z0-9]+;/DEVELOPMENT_TEAM = "";/g' "$PODS_PBX"
          perl -pi -e 's/(CODE_SIGN_IDENTITY(\[sdk=iphoneos\*\])?) = [^;]*;/\1 = "";/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGNING_ALLOWED = YES;/CODE_SIGNING_ALLOWED = NO;/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGNING_REQUIRED = YES;/CODE_SIGNING_REQUIRED = NO;/g' "$PODS_PBX"

      - name: Archive
        shell: bash
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/archive
          cd ios

          xcodebuild \
            -workspace Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            archive

      - name: Export IPA
        shell: bash
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/ipa
          cd ios

          xcodebuild -exportArchive \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath ../build/ios/ipa \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa
          path: build/ios/ipa/**/*.ipa
          if-no-files-found: error

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # TESTFLIGHT UPLOAD & EXTERNAL TESTING SETUP
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Upload to TestFlight (External Testing)
        shell: bash
        run: |
          set -euo pipefail
          
          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          IPA_PATH="$(find "$GITHUB_WORKSPACE/build/ios/ipa" -type f -name "*.ipa" | head -n 1)"
          
          echo "ğŸ“¤ Uploading to TestFlight for External Testing..."
          echo "âš ï¸  Note: External builds require Apple's beta review (24-48 hours)"
          
          fastlane pilot upload \
            --ipa "$IPA_PATH" \
            --api_key_path "$API_KEY_JSON" \
            --app_identifier "$BUNDLE_ID" \
            --skip_waiting_for_build_processing false \
            --distribute_external false \
            --skip_submission false \
            --changelog "Initial beta release for testing"
      
          echo "âœ… Upload complete!"
          echo "â³ Build submitted for external beta review"

      - name: ğŸš€ Complete External TestFlight Setup (Dynamic)
        shell: bash
        run: |
          set -euo pipefail

          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          APP_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")"

          echo '${{ toJson(github.event.client_payload) }}' > /tmp/ci_payload.json

          python3 - <<'PY' > /tmp/owner_env.sh
          import json, shlex, os
          p = json.load(open("/tmp/ci_payload.json"))
          cfg = p.get("CONFIG") or {}
          owner_email = (cfg.get("ownerEmail") or "").strip()
          owner_name  = (cfg.get("ownerName") or "Owner").strip() or "Owner"
          print("OWNER_EMAIL=" + shlex.quote(owner_email))
          print("OWNER_NAME="  + shlex.quote(owner_name))
          PY

          source /tmp/owner_env.sh

          if [ -z "${OWNER_EMAIL:-}" ]; then
            echo "âš ï¸ ownerEmail not provided, skipping TestFlight setup"
            exit 0
          fi

          echo "ğŸ“§ Owner: $OWNER_EMAIL ($OWNER_NAME)"
          echo "ğŸ“± App: $APP_NAME"
          echo "ğŸ†” Bundle: $BUNDLE_ID"
          echo ""

          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "$OWNER_EMAIL" "$OWNER_NAME" "$APP_NAME" "${BETA_APP_DESCRIPTION:-}" "${BETA_FEEDBACK_EMAIL:-}" "${BETA_CONTACT_PHONE:-}" <<'PYEOF'
          import json, jwt, time, requests, sys

          api_key = json.load(open(sys.argv[1]))

          def create_token():
              return jwt.encode({
                  'iss': api_key['issuer_id'],
                  'iat': int(time.time()),
                  'exp': int(time.time()) + 1200,
                  'aud': 'appstoreconnect-v1'
              }, api_key['key'], algorithm='ES256',
              headers={'kid': api_key['key_id'], 'typ': 'JWT'})

          def h():
              return {
                  "Authorization": f"Bearer {create_token()}",
                  "Content-Type": "application/json"
              }

          bundle_id = sys.argv[2]
          owner_email = sys.argv[3]
          owner_name = sys.argv[4]
          app_name = sys.argv[5]
          beta_description = sys.argv[6] if len(sys.argv) > 6 else f"Test {app_name} and provide feedback"
          feedback_email = sys.argv[7] if len(sys.argv) > 7 else owner_email
          contact_phone = sys.argv[8] if len(sys.argv) > 8 else "+1234567890"

          print("="*70)
          print("ğŸš€ COMPLETE EXTERNAL TESTFLIGHT SETUP")
          print("="*70)
          print()
          print(f"ğŸ“§ Feedback Email: {feedback_email}")
          print(f"ğŸ“± Contact Phone: {contact_phone}")
          print()

          print("ğŸ“± Step 1: Finding app in App Store Connect...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}",
              headers=h()
          )
          r.raise_for_status()
          apps = r.json()['data']
          if not apps:
              print(f"âŒ App not found: {bundle_id}")
              sys.exit(1)
          app_id = apps[0]['id']
          print(f"   âœ… App found: {app_id}")
          print()

          print("ğŸ§ª Step 2: Setting up external beta tester...")
          tester_id = None
          
          try:
              r = requests.get(
                  f"https://api.appstoreconnect.apple.com/v1/betaTesters?filter[email]={owner_email}",
                  headers=h()
              )
              
              if r.status_code == 200:
                  global_testers = r.json()['data']
                  if global_testers:
                      tester_id = global_testers[0]['id']
                      print(f"   âœ… Beta tester exists: {tester_id}")
          except Exception as e:
              print(f"   âš ï¸  Error checking testers: {str(e)[:100]}")
          
          if not tester_id:
              try:
                  print(f"   âš™ï¸  Creating external beta tester...")
                  first = owner_name.split()[0] if owner_name.strip() else "Owner"
                  last  = " ".join(owner_name.split()[1:]) if len(owner_name.split()) > 1 else ""
                  
                  r = requests.post(
                      "https://api.appstoreconnect.apple.com/v1/betaTesters",
                      headers=h(),
                      json={
                          "data": {
                              "type": "betaTesters",
                              "attributes": {
                                  "email": owner_email,
                                  "firstName": first,
                                  "lastName": last
                              }
                          }
                      }
                  )
                  
                  if r.status_code in (200, 201):
                      tester_id = r.json()['data']['id']
                      print(f"   âœ… External beta tester created: {tester_id}")
                  elif r.status_code == 409:
                      r2 = requests.get(
                          f"https://api.appstoreconnect.apple.com/v1/betaTesters?filter[email]={owner_email}",
                          headers=h()
                      )
                      if r2.status_code == 200:
                          global_testers = r2.json()['data']
                          if global_testers:
                              tester_id = global_testers[0]['id']
                              print(f"   âœ… Found existing tester: {tester_id}")
                  else:
                      print(f"   âš ï¸  Beta tester creation: {r.status_code}")
              except Exception as e:
                  print(f"   âš ï¸  Error creating tester: {str(e)[:100]}")
          
          if not tester_id:
              print(f"   âŒ Could not create or find beta tester")
              sys.exit(0)
          
          print()

          print("ğŸ‘¥ Step 3: Setting up external testing group with public link...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/betaGroups?filter[app]={app_id}&filter[isInternalGroup]=false",
              headers=h()
          )
          r.raise_for_status()
          groups = r.json()['data']
          
          group_id = None
          group_name = None
          public_link_enabled = False
          
          for group in groups:
              if group['attributes'].get('publicLinkEnabled', False):
                  group_id = group['id']
                  group_name = group['attributes']['name']
                  public_link_enabled = True
                  print(f"   âœ… Public external group exists: '{group_name}'")
                  break
          
          if not group_id and groups:
              group_id = groups[0]['id']
              group_name = groups[0]['attributes']['name']
              public_link_enabled = groups[0]['attributes'].get('publicLinkEnabled', False)
              print(f"   âœ… External group exists: '{group_name}'")
          
          if not group_id:
              print(f"   âš™ï¸  Creating external testing group with public link...")
              r = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaGroups",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaGroups",
                          "attributes": {
                              "name": "External Testers",
                              "isInternalGroup": False,
                              "publicLinkEnabled": True,
                              "publicLinkLimitEnabled": False
                          },
                          "relationships": {
                              "app": {"data": {"type": "apps", "id": app_id}}
                          }
                      }
                  }
              )
              
              if r.status_code in (200, 201):
                  group_data = r.json()['data']
                  group_id = group_data['id']
                  group_name = group_data['attributes']['name']
                  public_link_enabled = True
                  print(f"   âœ… External group created: '{group_name}'")
              else:
                  print(f"   âŒ Could not create external group (status {r.status_code})")
                  sys.exit(1)
          
          if not public_link_enabled:
              print(f"   âš™ï¸  Enabling public link on group '{group_name}'...")
              try:
                  r = requests.patch(
                      f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}",
                      headers=h(),
                      json={
                          "data": {
                              "type": "betaGroups",
                              "id": group_id,
                              "attributes": {
                                  "publicLinkEnabled": True,
                                  "publicLinkLimitEnabled": False
                              }
                          }
                      }
                  )
                  if r.status_code == 200:
                      print(f"   âœ… Public link enabled")
                      public_link_enabled = True
                  else:
                      print(f"   âš ï¸  Could not enable public link: {r.status_code}")
              except Exception as e:
                  print(f"   âš ï¸  Error enabling public link: {str(e)[:100]}")
          
          print()

          print("ğŸ”— Step 4: Retrieving public TestFlight link...")
          public_testflight_link = None
          
          try:
              r = requests.get(
                  f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}",
                  headers=h()
              )
              
              if r.status_code == 200:
                  public_testflight_link = r.json()['data']['attributes'].get('publicLink')
                  if public_testflight_link:
                      print(f"   âœ… Public TestFlight Link:")
                      print(f"   ğŸ”— {public_testflight_link}")
                      print()
                      
                      with open("testflight_public_link.txt", "w") as f:
                          f.write(public_testflight_link)
                  else:
                      print("   âš ï¸  Public link not available yet (will be generated after first build)")
              else:
                  print(f"   âš ï¸  Could not retrieve group details: {r.status_code}")
          except Exception as e:
              print(f"   âš ï¸  Error retrieving public link: {str(e)[:100]}")
          
          print()

          print("ğŸ”— Step 5: Adding tester to external group...")
          r = requests.post(
              f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/betaTesters",
              headers=h(),
              json={"data":[{"type":"betaTesters","id":tester_id}]}
          )
          if r.status_code in (200, 204):
              print("   âœ… Tester added to external group")
          elif r.status_code == 409:
              print("   âœ… Tester already in external group")
          else:
              print(f"   âš ï¸  Response: {r.status_code}")
          print()

          print("â³ Step 6: Waiting for build to finish processing...")
          build_id = None
          version = None
          build_num = None
          max_retries = 20
          
          for attempt in range(max_retries):
              r = requests.get(
                  f"https://api.appstoreconnect.apple.com/v1/builds?filter[app]={app_id}&sort=-uploadedDate&limit=1",
                  headers=h()
              )
              r.raise_for_status()
              builds = r.json()['data']
              
              if builds:
                  build_id = builds[0]['id']
                  version = builds[0]['attributes']['version']
                  build_num = builds[0]['attributes'].get('buildNumber','')
                  processing_state = builds[0]['attributes'].get('processingState', 'PROCESSING')
                  
                  if processing_state == 'VALID':
                      print(f"   âœ… Build ready: {version} ({build_num})")
                      break
                  else:
                      print(f"   â³ Build {version} {processing_state} - attempt {attempt+1}/{max_retries}")
                  
                  if attempt < max_retries - 1:
                      time.sleep(30)
              else:
                  print(f"   â³ No builds found yet - attempt {attempt+1}/{max_retries}")
                  if attempt < max_retries - 1:
                      time.sleep(30)
          
          if not build_id:
              print()
              print("   âš ï¸  Build not ready yet")
              print("   ğŸ’¡ Setup complete - build will appear after processing")
              print()
              
              with open("testflight_status.txt", "w") as f:
                  f.write("PENDING_BUILD")
              
              if public_testflight_link:
                  print("=" * 70)
                  print("ğŸ”— PUBLIC TESTFLIGHT LINK (Ready to share)")
                  print("=" * 70)
                  print(public_testflight_link)
                  print("=" * 70)
              
              sys.exit(0)
          print()

          print("ğŸ”’ Step 7: Setting export compliance...")
          try:
              r = requests.patch(
                  f"https://api.appstoreconnect.apple.com/v1/builds/{build_id}",
                  headers=h(),
                  json={
                      "data": {
                          "type": "builds",
                          "id": build_id,
                          "attributes": {
                              "usesNonExemptEncryption": False
                          }
                      }
                  }
              )
              if r.status_code == 200:
                  print("   âœ… Export compliance set")
                  time.sleep(5)
              elif r.status_code == 409:
                  print("   âœ… Export compliance already set")
              else:
                  print(f"   â„¹ï¸  Export compliance: {r.status_code}")
          except Exception as e:
              print(f"   âš ï¸  {str(e)[:80]}")
          print()

          print("ğŸ“ Step 8: Adding beta build localization...")
          try:
              whats_new_text = f"Welcome to {app_name} beta! Please test all features and provide feedback."
              
              r = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaBuildLocalizations",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaBuildLocalizations",
                          "attributes": {
                              "locale": "en-US",
                              "whatsNew": whats_new_text
                          },
                          "relationships": {
                              "build": {"data": {"type": "builds", "id": build_id}}
                          }
                      }
                  }
              )
              
              if r.status_code in (200, 201):
                  print("   âœ… Beta build localization added")
                  print(f"   ğŸ“ What's New: {whats_new_text}")
              elif r.status_code == 409:
                  print("   âœ… Beta build localization already exists")
              else:
                  print(f"   â„¹ï¸  Beta localization response: {r.status_code}")
          except Exception as e:
              print(f"   âš ï¸  {str(e)[:80]}")
          
          print()

          print("ğŸ“¦ Step 9: Adding build to external testing group...")
          build_added = False
          max_build_retries = 15
          
          for attempt in range(max_build_retries):
              r = requests.post(
                  f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/builds",
                  headers=h(),
                  json={"data":[{"type":"builds","id":build_id}]}
              )
              
              if r.status_code in (200, 204):
                  print("   âœ… Build added to external group!")
                  build_added = True
                  break
              elif r.status_code == 409:
                  print("   âœ… Build already in external group!")
                  build_added = True
                  break
              elif r.status_code == 422:
                  print(f"   â³ Build not ready - attempt {attempt+1}/{max_build_retries}")
                  if attempt < max_build_retries - 1:
                      time.sleep(30)
              else:
                  print(f"   âš ï¸  Response: {r.status_code}")
                  if attempt < max_build_retries - 1:
                      time.sleep(30)
          
          print()

          print("ğŸ“‹ Step 10: Submitting build for Beta App Review...")
          review_submitted = False
          
          try:
              r = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaAppReviewSubmissions",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaAppReviewSubmissions",
                          "relationships": {
                              "build": {"data": {"type": "builds", "id": build_id}}
                          }
                      }
                  }
              )
              
              if r.status_code in (200, 201):
                  submission = r.json()['data']
                  review_state = submission['attributes'].get('betaReviewState', 'WAITING_FOR_REVIEW')
                  print(f"   âœ… Submitted for review (State: {review_state})")
                  print("   â³ Apple will review within 24-48 hours")
                  review_submitted = True
              elif r.status_code == 409:
                  print("   âœ… Already submitted for review")
                  review_submitted = True
              else:
                  print(f"   âš ï¸  Submission response: {r.status_code}")
                  if r.status_code == 422:
                      error = r.json().get('errors', [{}])[0]
                      print(f"   ğŸ’¡ {error.get('detail', 'Build may not be ready yet')}")
          except Exception as e:
              print(f"   âš ï¸  Error submitting for review: {str(e)[:100]}")
          
          print()

          if not public_testflight_link:
              print("ğŸ”— Step 11: Re-checking for public TestFlight link...")
              try:
                  time.sleep(5)
                  r = requests.get(
                      f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}",
                      headers=h()
                  )
                  
                  if r.status_code == 200:
                      public_testflight_link = r.json()['data']['attributes'].get('publicLink')
                      if public_testflight_link:
                          print(f"   âœ… Public link now available!")
                          with open("testflight_public_link.txt", "w") as f:
                              f.write(public_testflight_link)
                      else:
                          print("   â„¹ï¸  Public link will be generated after review approval")
              except Exception as e:
                  print(f"   âš ï¸  {str(e)[:80]}")
              print()

          status = "SUBMITTED_FOR_REVIEW" if review_submitted else "BUILD_ADDED"
          with open("testflight_status.txt", "w") as f:
              f.write(status)

          print()
          print("=" * 70)
          
          if build_added and review_submitted:
              print("ğŸ‰ âœ… EXTERNAL TESTING FULLY CONFIGURED!")
              print("=" * 70)
              print(f"ğŸ“§ Owner: {owner_email}")
              print(f"ğŸ“± App: {app_name}")
              print(f"ğŸ“¦ Build: {version} ({build_num})")
              print(f"ğŸ‘¥ Group: {group_name}")
              print(f"ğŸ“‹ Review: Submitted for Apple Beta Review")
              print()
              
              if public_testflight_link:
                  print("ğŸ”— PUBLIC TESTFLIGHT LINK:")
                  print(f"   {public_testflight_link}")
                  print()
                  print("ğŸ“² Share this link with external testers")
                  print("â³ Link will work after Apple approves (24-48 hours)")
              else:
                  print("â„¹ï¸  Public TestFlight link will be available after review")
              
              print()
              print("â³ NEXT STEPS:")
              print("   1. Apple reviews build (24-48 hours)")
              print("   2. Tester receives email invitation")
              print("   3. Tester installs TestFlight app")
              print("   4. Tester clicks link or enters code")
              print("   5. App becomes available in TestFlight")
          else:
              print("âš ï¸  SETUP PARTIALLY COMPLETE")
              print("=" * 70)
              print(f"ğŸ“§ Owner: {owner_email}")
              print(f"ğŸ“± App: {app_name}")
              
              if public_testflight_link:
                  print()
                  print(f"ğŸ”— Public Link: {public_testflight_link}")
              
              print()
              print("ğŸ’¡ Build processing - check back in a few minutes")
          
          print("=" * 70)
          PYEOF

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # ğŸ’¾ CALLBACK â€“ save TestFlight link to DB, uses $DEMO_EMAIL /
      #    $DEMO_PASSWORD from GITHUB_ENV everywhere (no hardcoding)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ’¾ Save TestFlight Public Link to Database
        if: always()
        shell: bash
        run: |
          set -uo pipefail
          
          # â”€â”€â”€ Load variables â”€â”€â”€
          API_BASE="$(cat ci_api_base.txt)"
          LINK_ID="$(cat ci_link_id.txt)"
          BUNDLE_ID="$(cat ci_ios_bundle_id.txt)"
          APP_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")"
          VERSION_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['IOS_VERSION_NAME'])")"
          BUILD_NUMBER="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['IOS_BUILD_NUMBER'])")"
          
          # â”€â”€â”€ Read TestFlight public link â”€â”€â”€
          TESTFLIGHT_LINK=""
          if [ -f "testflight_public_link.txt" ]; then
            TESTFLIGHT_LINK="$(cat testflight_public_link.txt | tr -d '\r\n')"
          fi
          
          # â”€â”€â”€ Read build status â”€â”€â”€
          BUILD_STATUS="uploaded"
          if [ -f "testflight_status.txt" ]; then
            BUILD_STATUS="$(cat testflight_status.txt | tr -d '\r\n')"
          fi
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "          ğŸ’¾ SAVING TESTFLIGHT PUBLIC LINK TO DATABASE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“± App Name:          $APP_NAME"
          echo "ğŸ†” Bundle ID:         $BUNDLE_ID"
          echo "ğŸ“¦ Version:           $VERSION_NAME ($BUILD_NUMBER)"
          echo "ğŸ“‹ Status:            $BUILD_STATUS"
          echo "ğŸ”— TestFlight Link:   ${TESTFLIGHT_LINK:-âš ï¸  NOT AVAILABLE}"
          echo ""
          
          # â”€â”€â”€ Build the callback payload â”€â”€â”€
          cat > callback_payload.json <<EOF
          {
            "linkId": "$LINK_ID",
            "platform": "ios",
            "bundleId": "$BUNDLE_ID",
            "appName": "$APP_NAME",
            "version": "$VERSION_NAME",
            "buildNumber": "$BUILD_NUMBER",
            "status": "$BUILD_STATUS",
            "testflightPublicLink": "$TESTFLIGHT_LINK",
            "downloadUrl": "$TESTFLIGHT_LINK",
            "githubArtifactUrl": "$TESTFLIGHT_LINK",
            "iosTestflightLink": "$TESTFLIGHT_LINK",
            "publicLink": "$TESTFLIGHT_LINK",
            "message": "Build uploaded to TestFlight and submitted for external beta review. Build will be available to testers after Apple approval (24-48 hours).",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          echo "ğŸ“„ Callback Payload:"
          cat callback_payload.json | python3 -m json.tool 2>/dev/null || cat callback_payload.json
          echo ""
          
          # â”€â”€â”€ Guard: need token + api base â”€â”€â”€
          if [ -z "${CI_CALLBACK_TOKEN:-}" ] || [ -z "$API_BASE" ]; then
            echo "âš ï¸ Missing CI_CALLBACK_TOKEN or API_BASE â€” cannot save to DB"
            echo "   Set these secrets in GitHub repository settings"
            exit 0
          fi
          
          # â”€â”€â”€ POST callback with retry (3 attempts) â”€â”€â”€
          CALLBACK_URL="$API_BASE/api/ci/callback/testflight"
          echo "ğŸ“¡ Posting to: $CALLBACK_URL"
          echo ""
          
          MAX_ATTEMPTS=3
          ATTEMPT=0
          SUCCESS=false
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "ğŸ”„ Attempt $ATTEMPT / $MAX_ATTEMPTS ..."
          
            if CALLBACK_RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              -H "X-Auth-Token: $CI_CALLBACK_TOKEN" \
              -d @callback_payload.json 2>&1); then
              
              HTTP_CODE=$(echo "$CALLBACK_RESPONSE" | tail -n1)
              RESPONSE_BODY=$(echo "$CALLBACK_RESPONSE" | sed '$d')
              
              if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
                echo "   âœ… Callback successful (HTTP $HTTP_CODE) â€” TestFlight link saved to DB!"
                echo "   Response: $RESPONSE_BODY"
                SUCCESS=true
                break
              else
                echo "   âš ï¸  Callback returned HTTP $HTTP_CODE"
                echo "   Response: $RESPONSE_BODY"
                
                if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                  echo "   â³ Retrying in 5 seconds..."
                  sleep 5
                fi
              fi
            else
              CURL_EXIT=$?
              echo "   âš ï¸  Callback failed (curl exit code: $CURL_EXIT)"
              echo "   Error: $CALLBACK_RESPONSE"
              
              case $CURL_EXIT in
                6) echo "   ğŸ’¡ Could not resolve host - check network configuration" ;;
                7) echo "   ğŸ’¡ Failed to connect to host" ;;
                28) echo "   ğŸ’¡ Timeout connecting to server" ;;
                *) echo "   ğŸ’¡ Check API endpoint and network settings" ;;
              esac
              
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "   â³ Retrying in 5 seconds..."
                sleep 5
              fi
            fi
          done
          
          echo ""
          
          if [ "$SUCCESS" = "false" ]; then
            echo "âŒ All $MAX_ATTEMPTS callback attempts failed"
            echo "   ğŸ’¡ The TestFlight link was NOT saved to database"
            echo "   ğŸ’¡ Link value: ${TESTFLIGHT_LINK:-EMPTY}"
            echo "   ğŸ’¡ Check your backend endpoint: $CALLBACK_URL"
            echo "   ğŸ’¡ Verify CI_CALLBACK_TOKEN secret is correct"
            echo ""
            echo "   ğŸ”§ Debug steps:"
            echo "   1. Check if backend is running"
            echo "   2. Test endpoint manually: curl -X POST $CALLBACK_URL"
            echo "   3. Verify CI_CALLBACK_TOKEN in GitHub Secrets"
            echo "   4. Check backend logs for errors"
          else
            echo "âœ… TestFlight public link successfully saved to database!"
          fi
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "                    ğŸ‰ BUILD COMPLETE ğŸ‰"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“± App Name:       $APP_NAME"
          echo "ğŸ†” Bundle ID:      $BUNDLE_ID"
          echo "ğŸ“¦ Version:        $VERSION_NAME ($BUILD_NUMBER)"
          echo "ğŸ“‹ Status:         $BUILD_STATUS"
          echo "ğŸ’¾ Saved to DB:    $([ "$SUCCESS" = "true" ] && echo "âœ… YES" || echo "âŒ NO")"
          echo ""
          
          if [ -n "$TESTFLIGHT_LINK" ]; then
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "           ğŸ”— PUBLIC TESTFLIGHT LINK (Ready to Share)"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "$TESTFLIGHT_LINK"
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“² SHARE THIS LINK WITH BETA TESTERS"
            echo ""
            echo "â³ IMPORTANT NOTES:"
            echo "   â€¢ Link is active immediately"
            echo "   â€¢ Build requires Apple Beta Review (24-48 hours)"
            echo "   â€¢ Testers will receive email when build is approved"
            echo "   â€¢ Testers need TestFlight app installed"
            echo ""
            echo "ğŸ” DEMO CREDENTIALS (from endpoint):"
            echo "   ğŸ“§ Email:    $DEMO_EMAIL"
            echo "   ğŸ”‘ Password: $DEMO_PASSWORD"
            echo ""
            echo "ğŸ“§ WHAT TESTERS SHOULD DO:"
            echo "   1. Install TestFlight app from App Store"
            echo "   2. Click the public link above (or received via email)"
            echo "   3. Accept the invitation"
            echo "   4. Wait for Apple approval notification"
            echo "   5. Download and test the app"
            echo ""
          else
            echo "â„¹ï¸  TestFlight Link: Will be available after first build approval"
            echo ""
          fi
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # â”€â”€â”€ GitHub Step Summary â”€â”€â”€
          {
            echo "## ğŸ‰ iOS Build Complete"
            echo ""
            echo "| Field | Value |"
            echo "|---|---|"
            echo "| App Name | $APP_NAME |"
            echo "| Bundle ID | $BUNDLE_ID |"
            echo "| Version | $VERSION_NAME ($BUILD_NUMBER) |"
            echo "| Status | $BUILD_STATUS |"
            echo "| Saved to DB | $([ "$SUCCESS" = "true" ] && echo 'âœ… Yes' || echo 'âŒ No') |"
            echo ""
            
            if [ -n "$TESTFLIGHT_LINK" ]; then
              echo "### ğŸ”— Public TestFlight Link"
              echo ""
              echo "\`\`\`"
              echo "$TESTFLIGHT_LINK"
              echo "\`\`\`"
              echo ""
              echo "**Demo Credentials (from endpoint):**"
              echo "- Email: \`$DEMO_EMAIL\`"
              echo "- Password: \`$DEMO_PASSWORD\`"
              echo ""
              echo "### ğŸ“² Next Steps"
              echo ""
              echo "1. âœ… Share the TestFlight link with beta testers"
              echo "2. â³ Apple will review the build (24-48 hours)"
              echo "3. ğŸ“§ Testers will receive email notification when approved"
              echo "4. ğŸ“± Testers install TestFlight app and access the build"
              echo ""
              
              if [ "$SUCCESS" = "true" ]; then
                echo "### âœ… Database Status"
                echo ""
                echo "TestFlight public link has been successfully saved to your database."
                echo ""
              else
                echo "### âš ï¸ Database Status"
                echo ""
                echo "**Warning:** Failed to save TestFlight link to database after $MAX_ATTEMPTS attempts."
                echo ""
                echo "**Troubleshooting:**"
                echo "- Check if backend endpoint is accessible: \`$CALLBACK_URL\`"
                echo "- Verify \`CI_CALLBACK_TOKEN\` secret is set correctly"
                echo "- Review backend logs for errors"
                echo ""
              fi
            else
              echo "> â„¹ï¸ Public TestFlight link will be available after Apple approves the first build."
              echo ""
              echo "Once available, the link will be automatically saved to your database on the next build."
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          
          exit 0
