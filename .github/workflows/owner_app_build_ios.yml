name: Owner App Build (iOS) - External Testing Auto

on:
  repository_dispatch:
    types: [owner_app_build_ios]

permissions:
  contents: write

jobs:
  build-ios:
    runs-on: macos-15

    env:
      CI_CALLBACK_TOKEN: ${{ secrets.CI_CALLBACK_TOKEN }}
      CI_RUNTIME_TOKEN: ${{ secrets.CI_RUNTIME_TOKEN }}

      IOS_P12_B64: ${{ secrets.IOS_P12_B64 }}
      IOS_P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
      IOS_TEAM_ID: ${{ secrets.IOS_TEAM_ID }}
      IOS_EXPORT_METHOD: ${{ secrets.IOS_EXPORT_METHOD }}

      ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
      ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
      ASC_KEY_P8_B64: ${{ secrets.ASC_KEY_P8_B64 }}

      DEFAULT_BETA_APP_DESCRIPTION: ${{ secrets.DEFAULT_BETA_APP_DESCRIPTION }}
      DEFAULT_BETA_FEEDBACK_EMAIL: ${{ secrets.DEFAULT_BETA_FEEDBACK_EMAIL }}
      DEFAULT_BETA_CONTACT_PHONE: ${{ secrets.DEFAULT_BETA_CONTACT_PHONE }}

      SPACESHIP_CONNECT_API_IN_HOUSE: "false"
      COCOAPODS_DISABLE_STATS: "true"
      FASTLANE_OPT_OUT_USAGE: "true"
      LANG: en_US.UTF-8
      LC_ALL: en_US.UTF-8

    steps:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # CHECKOUT & TOOLING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select newest installed Xcode (safe)
        shell: bash
        run: |
          set -euo pipefail
      
          echo "ğŸ” Installed Xcodes:"
          ls -1 /Applications | grep -E '^Xcode.*\.app$' || true
      
          XCODE_APP="$(ls -1 /Applications | grep -E '^Xcode.*\.app$' | sort -V | tail -n 1)"
      
          if [ -z "${XCODE_APP:-}" ]; then
            echo "âŒ No Xcode found in /Applications"
            exit 1
          fi
      
          echo "âœ… Selected: $XCODE_APP"
          sudo xcode-select -s "/Applications/$XCODE_APP/Contents/Developer"
      
          xcodebuild -version
          echo "iOS SDK: $(xcrun --sdk iphoneos --show-sdk-version)"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.32.0"
          channel: stable
          cache: true

      - name: Flutter pub get
        shell: bash
        run: |
          set -euo pipefail
          flutter --version
          flutter pub get

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # RUNTIME CONFIG
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Show dispatch payload (debug)
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          print(json.dumps(payload, ensure_ascii=False, indent=2))
          PY


          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # EXTRACT BUILD_ID & LINK_ID (needed for status callbacks)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Extract BUILD_ID and LINK_ID
        shell: bash
        run: |
          set -e
          python3 - <<'PY'
          import json, os
          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}
          
          build_id = (
              (payload.get("BUILD_ID") or "")
              or (payload.get("buildId") or "")
              or ""
          ).strip()
          
          link_id = str(
              cfg.get("OWNER_PROJECT_LINK_ID")
              or payload.get("OWNER_PROJECT_LINK_ID")
              or payload.get("ownerProjectLinkId")
              or cfg.get("ownerProjectLinkId")
              or ""
          ).strip()
          
          api_base = (cfg.get("API_BASE_URL") or payload.get("API_BASE_URL") or "").rstrip("/")
          
          open("ci_build_id.txt","w",encoding="utf-8").write(build_id)
          
          print("BUILD_ID =", build_id if build_id else "(empty)")
          print("LINK_ID (will be set by ci_env.json step) =", link_id if link_id else "(empty)")
          print("API_BASE (will be set by ci_env.json step) =", api_base if api_base else "(empty)")
          
          # Export BUILD_ID to GITHUB_ENV for all steps
          with open(os.environ["GITHUB_ENV"], "a") as f:
              f.write(f"BUILD_ID={build_id}\n")
          PY

      - name: Build ci_env.json (BY_LINK runtime-config + fallback + B64)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p lib/env

          python3 - <<'PY'
          import json, os, urllib.request, urllib.error, socket, re

          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          api_base = (cfg.get("API_BASE_URL") or payload.get("API_BASE_URL") or "").rstrip("/")
          link_id = str(
              cfg.get("OWNER_PROJECT_LINK_ID")
              or payload.get("OWNER_PROJECT_LINK_ID")
              or payload.get("ownerProjectLinkId")
              or cfg.get("ownerProjectLinkId")
              or ""
          ).strip()

          if not api_base:
              raise SystemExit("Missing API_BASE_URL")
          if not link_id:
              raise SystemExit("Missing OWNER_PROJECT_LINK_ID")

          url = f"{api_base}/api/public/runtime-config/by-link?linkId={link_id}"
          runtime = {}
          source = "FALLBACK (payload/defaults)"

          token = (os.getenv("CI_RUNTIME_TOKEN") or "").strip()
          headers = {"Accept": "application/json"}
          if token:
              headers["X-Auth-Token"] = token

          try:
              print("Fetching runtime config:", url)
              print("Auth header present =", "YES" if token else "NO")
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=12) as r:
                  raw = r.read().decode("utf-8")
                  runtime = json.loads(raw)
              source = "BY_LINK"
          except (urllib.error.HTTPError, urllib.error.URLError, socket.timeout, json.JSONDecodeError) as e:
              print("âš ï¸ runtime-config fetch failed, using fallback:", repr(e))

          print("CONFIG SOURCE =", source)

          def pick(key, default=None):
              v = runtime.get(key)
              if v not in (None, "", []):
                  return v
              v = cfg.get(key)
              if v not in (None, "", []):
                  return v
              v = payload.get(key)
              if v not in (None, "", []):
                  return v
              return default

          app_name = pick("APP_NAME", "My App")
          app_type = pick("APP_TYPE", "ECOMMERCE")
          project_id = str(pick("PROJECT_ID", "")).strip()

          ios_bundle = (
              pick("iosBundleId") or 
              pick("IOS_BUNDLE_ID") or 
              pick("PACKAGE_NAME") or 
              pick("APPLICATION_ID") or 
              ""
          ).strip()

          if not ios_bundle:
              ios_bundle = f"com.build4all.app{link_id}"
          
          ios_bundle = ios_bundle.lower()
          ios_bundle = re.sub(r"[^a-z0-9._]", "", ios_bundle)
          ios_bundle = re.sub(r"\.+", ".", ios_bundle).strip(".")
          
          if not ios_bundle or ios_bundle.count(".") < 1:
              ios_bundle = f"com.build4all.app{link_id}"

          vc = pick("IOS_BUILD_NUMBER") or pick("iosBuildNumber") or pick("ANDROID_VERSION_CODE")
          vn = pick("IOS_VERSION_NAME") or pick("iosVersionName") or pick("ANDROID_VERSION_NAME")

          try:
              vc_int = int(vc) if vc not in (None,"",[]) else None
          except Exception:
              vc_int = None

          vn_str = (str(vn).strip() if vn not in (None,"",[]) else "")

          env = {
              "API_BASE_URL": api_base,
              "APP_NAME": app_name,
              "APP_TYPE": app_type,
              "OWNER_PROJECT_LINK_ID": link_id,
              "PROJECT_ID": project_id,
              "IOS_BUNDLE_ID": ios_bundle,
              "IOS_BUILD_NUMBER": vc_int if vc_int is not None else 1,
              "IOS_VERSION_NAME": vn_str if vn_str else "1.0.0",
              "CONFIG_SOURCE": source,
          }

          currency_id = pick("CURRENCY_ID")
          if currency_id in (None, "", []):
              currency_id = (
                  runtime.get("currencyId")
                  or cfg.get("currencyId")
                  or payload.get("currencyId")
              )
          if currency_id not in (None, "", []):
              env["CURRENCY_ID"] = str(currency_id).strip()

          for key in [
              "THEME_JSON_B64",
              "NAV_JSON_B64",
              "HOME_JSON_B64",
              "ENABLED_FEATURES_JSON_B64",
              "BRANDING_JSON_B64",
          ]:
              v = pick(key)
              if v:
                  env[key] = v

          logo_url = (pick("LOGO_URL") or pick("LOGO_PATH") or "").strip()
          if not logo_url:
              logo_url = (runtime.get("logoUrl") or cfg.get("logoUrl") or payload.get("logoUrl") or "").strip()
          if logo_url:
              env["LOGO_URL"] = logo_url

          open("ci_api_base.txt", "w", encoding="utf-8").write(api_base)
          open("ci_link_id.txt", "w", encoding="utf-8").write(link_id)
          open("ci_ios_bundle_id.txt", "w", encoding="utf-8").write(ios_bundle)

          with open("lib/env/ci_env.json", "w", encoding="utf-8") as f:
              json.dump(env, f, ensure_ascii=False, indent=2)

          print("âœ… ci_env.json written")
          print("API_BASE_URL =", api_base)
          print("OWNER_PROJECT_LINK_ID =", link_id)
          print("PROJECT_ID =", project_id)
          print("IOS_BUNDLE_ID =", ios_bundle)
          print("IOS_BUILD_NUMBER =", env["IOS_BUILD_NUMBER"])
          print("IOS_VERSION_NAME =", env["IOS_VERSION_NAME"])
          print("CURRENCY_ID =", env.get("CURRENCY_ID"))
          print("CONFIG_SOURCE =", source)
          print("LOGO_URL =", env.get("LOGO_URL"))

          for k in ["THEME_JSON_B64","NAV_JSON_B64","HOME_JSON_B64","ENABLED_FEATURES_JSON_B64","BRANDING_JSON_B64"]:
              print(k, "=", "YES" if env.get(k) else "NO")
          PY

      
    
      

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # MARK BUILD AS RUNNING (at start)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ“¡ Mark build RUNNING
        if: always()
        shell: bash
        run: |
          set +e
      
          API_BASE="$(cat ci_api_base.txt 2>/dev/null | tr -d '\r\n')"
          LINK_ID="$(cat ci_link_id.txt 2>/dev/null | tr -d '\r\n')"
      
          if [ -z "$API_BASE" ] || [ -z "$LINK_ID" ] || [ -z "${CI_CALLBACK_TOKEN:-}" ]; then
            echo "âš ï¸ Missing API_BASE / LINK_ID / CI_CALLBACK_TOKEN -> skipping"
            exit 0
          fi
      
          if [ -z "${BUILD_ID:-}" ]; then
            echo "âš ï¸ BUILD_ID missing -> skipping build-jobs RUNNING (would not update DB)"
            exit 0
          fi
      
          curl -sS -X PUT "${API_BASE}/api/ci/build-jobs/running" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Token: ${CI_CALLBACK_TOKEN}" \
            -d "{\"buildId\":\"${BUILD_ID}\",\"linkId\":\"${LINK_ID}\",\"platform\":\"IOS\"}" || true
      
          echo "âœ… Build marked as RUNNING"
             

      - name: Debug env
        shell: bash
        run: |
          echo "----- ci_env.json -----"
          cat lib/env/ci_env.json

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # ğŸ” DEMO ACCOUNT â€“ calls BOTH endpoints, parses real credentials
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ” Create Demo Account for Apple Review (this app)
        shell: bash
        run: |
          set -euo pipefail

          API_BASE="$(cat ci_api_base.txt)"
          LINK_ID="$(cat ci_link_id.txt)"

          echo "ğŸ” Creating demo account for this appâ€¦"
          echo "   API:     $API_BASE"
          echo "   Link ID: $LINK_ID"
          echo ""

          RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST \
            "$API_BASE/api/auth/demo/create-apple-review-account?ownerProjectLinkId=$LINK_ID" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Token: ${{ secrets.CI_RUNTIME_TOKEN }}" \
            2>&1)

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP $HTTP_CODE"
          echo "$BODY" | python3 -m json.tool 2>/dev/null || echo "$BODY"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "âš ï¸  Single-app demo account creation returned HTTP $HTTP_CODE"
            echo "    Continuing â€“ seed-all step will run next."
          fi

          # â”€â”€ Parse email + password from the response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          DEMO_EMAIL=$(echo "$BODY" | python3 -c "
          import sys, json
          try:
              print(json.load(sys.stdin).get('email',''))
          except:
              print('')
          " 2>/dev/null || echo "")

          DEMO_PASSWORD=$(echo "$BODY" | python3 -c "
          import sys, json
          try:
              print(json.load(sys.stdin).get('password',''))
          except:
              print('')
          " 2>/dev/null || echo "")

          # Fall back to the same defaults the Java endpoint uses
          [ -n "$DEMO_EMAIL"    ] || DEMO_EMAIL="demo@applereview.com"
          [ -n "$DEMO_PASSWORD" ] || DEMO_PASSWORD="AppleReview2026!"

          # â”€â”€ Export to GITHUB_ENV so every later step can read them â”€â”€â”€â”€â”€
          echo "DEMO_EMAIL=$DEMO_EMAIL"       >> "$GITHUB_ENV"
          echo "DEMO_PASSWORD=$DEMO_PASSWORD" >> "$GITHUB_ENV"
          echo "::add-mask::$DEMO_PASSWORD"


          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "        ğŸ” DEMO CREDENTIALS (parsed from endpoint)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "   ğŸ“§ Email:    $DEMO_EMAIL"
          echo "   ğŸ”‘ Password: $DEMO_PASSWORD"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: ğŸ” Seed Demo Account across all apps
        shell: bash
        run: |
          set -euo pipefail

          API_BASE="$(cat ci_api_base.txt)"

          echo "ğŸ” Seeding demo account for every appâ€¦"
          echo "   API: $API_BASE"
          echo ""

          RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST \
            "$API_BASE/api/auth/demo/seed-apple-review-account-all" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Token: ${{ secrets.CI_RUNTIME_TOKEN }}" \
            2>&1)

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP $HTTP_CODE"
          echo "$BODY" | python3 -m json.tool 2>/dev/null || echo "$BODY"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "âš ï¸  seed-all returned HTTP $HTTP_CODE â€“ continuing anyway"
          else
            echo "âœ… All apps seeded"
          fi

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # APP STORE CONNECT METADATA
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Read App Store Connect metadata
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os
          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          cfg = payload.get("CONFIG") or {}

          def pick(*keys):
            for k in keys:
              if k in payload and payload[k]:
                return payload[k]
              if k in cfg and cfg[k]:
                return cfg[k]
            return ""

          app_name = pick("APPLE_APP_NAME","appleAppName","appStoreAppName","ASC_APP_NAME")
          sku      = pick("APPLE_SKU","appleSku","appStoreSku","ASC_SKU")
          locale   = pick("APPLE_PRIMARY_LOCALE","applePrimaryLocale","primaryLocale","ASC_PRIMARY_LOCALE") or "en-US"
          
          beta_description = (
              pick("BETA_APP_DESCRIPTION","betaAppDescription") 
              or os.environ.get("DEFAULT_BETA_APP_DESCRIPTION", "")
              or "Test our app and provide feedback on features, usability, and overall experience."
          )
          
          feedback_email = (
              pick("BETA_FEEDBACK_EMAIL","betaFeedbackEmail","ownerEmail")
              or os.environ.get("DEFAULT_BETA_FEEDBACK_EMAIL", "")
              or pick("ownerEmail")
              or ""
          )
          
          contact_phone = (
              pick("BETA_CONTACT_PHONE","betaContactPhone")
              or os.environ.get("DEFAULT_BETA_CONTACT_PHONE", "")
              or "+1234567890"
          )
          
          marketing_url = pick("MARKETING_URL","marketingUrl") or ""
          privacy_url = pick("PRIVACY_POLICY_URL","privacyPolicyUrl") or ""

          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write(f"APPLE_APP_NAME={app_name}\n")
            f.write(f"APPLE_SKU={sku}\n")
            f.write(f"APPLE_PRIMARY_LOCALE={locale}\n")
            f.write(f"BETA_APP_DESCRIPTION={beta_description}\n")
            f.write(f"BETA_FEEDBACK_EMAIL={feedback_email}\n")
            f.write(f"BETA_CONTACT_PHONE={contact_phone}\n")
            f.write(f"MARKETING_URL={marketing_url}\n")
            f.write(f"PRIVACY_POLICY_URL={privacy_url}\n")

          print("APPLE_APP_NAME=", app_name)
          print("APPLE_SKU=", sku)
          print("APPLE_PRIMARY_LOCALE=", locale)
          print("BETA_APP_DESCRIPTION=", beta_description[:100] + "..." if len(beta_description) > 100 else beta_description)
          print("BETA_FEEDBACK_EMAIL=", feedback_email)
          print("BETA_CONTACT_PHONE=", contact_phone)
          print("MARKETING_URL=", marketing_url)
          print("PRIVACY_POLICY_URL=", privacy_url)
          PY

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # FLUTTER / iOS PROJECT SETUP
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Ensure iOS Podfile exists
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f "ios/Podfile" ]; then
            flutter create .
          fi
          test -f ios/Podfile

      - name: Set iOS version & build number (initial)
        shell: bash
        run: |
          set -euo pipefail
          
          python3 - <<'PY'
          import json, re
          
          cfg = json.load(open("lib/env/ci_env.json"))
          
          version_name = cfg.get("IOS_VERSION_NAME", "1.0.0")
          build_number = cfg.get("IOS_BUILD_NUMBER", 1)
          
          version_name = str(version_name).strip()
          build_number = str(build_number).strip()
          
          print(f"iOS Version: {version_name}")
          print(f"iOS Build Number (initial â€“ may be overridden by ASC auto-increment): {build_number}")
          
          info_plist = "ios/Runner/Info.plist"
          with open(info_plist, "r", encoding="utf-8") as f:
              content = f.read()
          
          content = re.sub(
              r"(<key>CFBundleShortVersionString</key>\s*<string>)[^<]*(</string>)",
              rf"\g<1>{version_name}\g<2>",
              content
          )
          
          content = re.sub(
              r"(<key>CFBundleVersion</key>\s*<string>)[^<]*(</string>)",
              rf"\g<1>{build_number}\g<2>",
              content
          )
          
          with open(info_plist, "w", encoding="utf-8") as f:
              f.write(content)
          
          print(f"âœ… Updated {info_plist}")
          PY

      - name: Add privacy strings to Info.plist
        shell: bash
        run: |
          set -euo pipefail
          
          INFO_PLIST="ios/Runner/Info.plist"
          
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'This app needs access to your photo library to allow you to select and upload images.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'This app needs access to your photo library to allow you to select and upload images.'" "$INFO_PLIST"
          
          /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'This app needs access to your camera to allow you to take and upload photos.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'This app needs access to your camera to allow you to take and upload photos.'" "$INFO_PLIST"
          
          /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'This app needs permission to save images to your photo library.'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'This app needs permission to save images to your photo library.'" "$INFO_PLIST"
          
          echo "âœ… Privacy strings added"

      - name: Apply branding (logo + app name)
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json, urllib.request, pathlib, shutil

          cfg = json.load(open("lib/env/ci_env.json","r",encoding="utf-8"))

          app_name_raw = cfg.get("APP_NAME","My App")
          api_base = (cfg.get("API_BASE_URL") or "").rstrip("/")
          logo_url = (cfg.get("LOGO_URL") or "").strip()

          print("APP_NAME:", app_name_raw)
          print("LOGO_URL (raw):", logo_url)
          print("API_BASE_URL:", api_base)

          pathlib.Path("assets/branding").mkdir(parents=True, exist_ok=True)

          if logo_url and logo_url.startswith("/") and api_base:
              logo_url = api_base + logo_url
              print("Resolved absolute LOGO_URL:", logo_url)

          if logo_url:
              try:
                  print("Downloading logo from:", logo_url)
                  urllib.request.urlretrieve(logo_url, "assets/branding/logo.png")
                  shutil.copyfile("assets/branding/logo.png","assets/branding/launcher.png")
                  shutil.copyfile("assets/branding/logo.png","assets/branding/splash.png")
                  print("âœ… Logo downloaded successfully")
              except Exception as e:
                  print("âš ï¸ Failed to download logo:", e)
                  print("Continuing without custom logo...")
          else:
              print("âš ï¸ No LOGO_URL provided, skipping logo download")
          PY

          flutter pub get
          flutter pub run flutter_launcher_icons || echo "âš ï¸ flutter_launcher_icons failed"
          flutter pub run flutter_native_splash:create || echo "âš ï¸ flutter_native_splash failed"

      - name: Set iOS App Name in Info.plist
        shell: bash
        run: |
          set -euo pipefail
          
          INFO_PLIST="ios/Runner/Info.plist"
          APP_NAME=$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")
          
          echo "Setting iOS App Name to: $APP_NAME"
          
          /usr/libexec/PlistBuddy -c "Add :CFBundleDisplayName string '$APP_NAME'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName '$APP_NAME'" "$INFO_PLIST"
          
          /usr/libexec/PlistBuddy -c "Set :CFBundleName '$APP_NAME'" "$INFO_PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :CFBundleName string '$APP_NAME'" "$INFO_PLIST"
          
          echo "âœ… iOS App Name set"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # CODE SIGNING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Setup iOS signing certificate
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${IOS_P12_B64:-}" ] || { echo "âŒ Missing IOS_P12_B64"; exit 1; }
          [ -n "${IOS_P12_PASSWORD:-}" ] || { echo "âŒ Missing IOS_P12_PASSWORD"; exit 1; }

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"

          security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db
          security default-keychain -s "$KEYCHAIN_PATH"

          echo "$IOS_P12_B64" | tr -d '\n\r ' | base64 --decode > ios_cert.p12
          security import ios_cert.p12 -k "$KEYCHAIN_PATH" -P "$IOS_P12_PASSWORD" -A \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"

          CNT=$(security find-identity -v -p codesigning | grep -c "Apple Distribution" || true)
          if [ "$CNT" -lt 1 ]; then
            echo "âŒ Apple Distribution identity not found"
            exit 1
          fi

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"

      - name: Install CocoaPods + fastlane
        shell: bash
        run: |
          set -euo pipefail
          gem install cocoapods -N
          gem install fastlane -N --force
          pod --version
          fastlane --version

      - name: Clean Pods
        shell: bash
        run: |
          set -euo pipefail
          rm -rf ios/Pods
          rm -f ios/Podfile.lock

      - name: Install iOS Pods
        shell: bash
        run: |
          set -euo pipefail
          cd ios
          pod install || { pod repo update; pod install; }

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # APP STORE CONNECT API KEY
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Create App Store Connect api_key.json
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .private

          [ -n "${ASC_KEY_ID:-}" ] || { echo "âŒ ASC_KEY_ID empty"; exit 1; }
          [ -n "${ASC_ISSUER_ID:-}" ] || { echo "âŒ ASC_ISSUER_ID empty"; exit 1; }
          [ -n "${ASC_KEY_P8_B64:-}" ] || { echo "âŒ ASC_KEY_P8_B64 empty"; exit 1; }

          echo "${ASC_KEY_P8_B64}" | base64 --decode > .private/AuthKey_${ASC_KEY_ID}.p8

          python3 - <<'PY'
          import json, pathlib, os

          key_path = pathlib.Path(f".private/AuthKey_{os.environ['ASC_KEY_ID']}.p8")
          
          try:
              p8_content = key_path.read_text(encoding='utf-8')
          except UnicodeDecodeError:
              try:
                  p8_content = key_path.read_bytes().decode('ascii')
              except:
                  p8_content = key_path.read_bytes().decode('latin-1')
                  print("âš ï¸ Warning: Using latin-1 fallback for key file")

          api_key_data = {
            "key_id": os.environ["ASC_KEY_ID"].strip(),
            "issuer_id": os.environ["ASC_ISSUER_ID"].strip(),
            "key": p8_content,
            "in_house": False
          }

          pathlib.Path(".private/api_key.json").write_text(
              json.dumps(api_key_data, ensure_ascii=False, indent=2)
          )
          
          print("âœ… api_key.json created successfully")
          PY
          
          echo "ğŸ” Verifying key file format..."
          if head -n 1 .private/AuthKey_${ASC_KEY_ID}.p8 | grep -q "BEGIN PRIVATE KEY"; then
            echo "âœ… Key file format looks correct"
          else
            echo "âš ï¸ Warning: Key file might not be in correct format"
            echo "First line:"
            head -n 1 .private/AuthKey_${ASC_KEY_ID}.p8
          fi

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PYTHON PACKAGES (consolidated â€“ used by ASC scripts below)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Install required Python packages
        shell: bash
        run: |
          python3 -m venv .venv
          source .venv/bin/activate
          python3 -m pip install --upgrade pip
          python3 -m pip install PyJWT cryptography requests
          echo "VIRTUAL_ENV=$VIRTUAL_ENV" >> $GITHUB_ENV
          echo "$VIRTUAL_ENV/bin" >> $GITHUB_PATH


      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # ğŸ”¢ AUTO-INCREMENT BUILD NUMBER FROM APP STORE CONNECT (FIXED)
      #    Queries ASC for the highest existing CFBundleVersion for this
      #    bundle ID and sets the new build to max + 1.  Runs AFTER
      #    api_key.json exists and BEFORE the archive step.
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Auto-increment build number from App Store Connect
        shell: bash
        run: |
          set -euo pipefail

          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          ENV_FILE="lib/env/ci_env.json"

          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "$ENV_FILE" <<'PY'
          import json, jwt, time, requests, sys, re

          api_key  = json.load(open(sys.argv[1]))
          bundle   = sys.argv[2]
          env_path = sys.argv[3]

          def token():
              return jwt.encode(
                  {"iss": api_key["issuer_id"],
                   "iat": int(time.time()),
                   "exp": int(time.time()) + 600,
                   "aud": "appstoreconnect-v1"},
                  api_key["key"], algorithm="ES256",
                  headers={"kid": api_key["key_id"], "typ": "JWT"})

          def h():
              return {"Authorization": f"Bearer {token()}",
                      "Content-Type": "application/json"}

          # â”€â”€ 1. Find the app â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ” Looking up app in ASC for bundle:", bundle)
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle}",
              headers=h())
          r.raise_for_status()
          apps = r.json()["data"]

          if not apps:
              # App doesn't exist in ASC yet (first-ever build) â€“ use epoch fallback
              env = json.load(open(env_path))
              fallback = int(time.time()) % 100000
              env["IOS_BUILD_NUMBER"] = fallback
              json.dump(env, open(env_path, "w"), indent=2)

              plist = "ios/Runner/Info.plist"
              content = open(plist).read()
              content = re.sub(
                  r"(<key>CFBundleVersion</key>\s*<string>)[^<]*(</string>)",
                  rf"\g<1>{fallback}\g<2>", content)
              open(plist, "w").write(content)

              print(f"âš ï¸  App not yet in ASC â€“ epoch fallback build number: {fallback}")
              sys.exit(0)

          app_id = apps[0]["id"]
          print(f"   App ID: {app_id}")

          # â”€â”€ 2. Page through builds, collect the max buildNumber â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # FIXED: Removed overly restrictive fields parameter
          max_bn = 0
          next_url = (
              f"https://api.appstoreconnect.apple.com/v1/builds"
              f"?filter[app]={app_id}&limit=100&sort=-uploadedDate"
          )

          pages = 0
          while next_url and pages < 5:          # safety cap â€“ 500 builds max
              r = requests.get(next_url, headers=h())
              r.raise_for_status()
              body = r.json()
              for b in body.get("data", []):
                  try:
                      val = int(b["attributes"]["buildNumber"])
                      if val > max_bn:
                          max_bn = val
                  except (KeyError, ValueError, TypeError):
                      pass
              next_url = body.get("links", {}).get("next")
              pages += 1

          new_bn = max_bn + 1
          print(f"   Max existing build number: {max_bn}")
          print(f"   âœ… New build number:        {new_bn}")

          # â”€â”€ 3. Patch ci_env.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          env = json.load(open(env_path))
          env["IOS_BUILD_NUMBER"] = new_bn
          json.dump(env, open(env_path, "w"), indent=2)

          # â”€â”€ 4. Patch Info.plist (already written by the initial step) â”€â”€â”€
          plist = "ios/Runner/Info.plist"
          content = open(plist).read()
          content = re.sub(
              r"(<key>CFBundleVersion</key>\s*<string>)[^<]*(</string>)",
              rf"\g<1>{new_bn}\g<2>", content)
          open(plist, "w").write(content)

          print(f"   âœ… Info.plist & ci_env.json updated to build number {new_bn}")
          PY

  

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # BETA APP REVIEW â€“ uses $DEMO_EMAIL / $DEMO_PASSWORD from GITHUB_ENV
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Setup Beta App Review Info with Demo Credentials
        shell: bash
        run: |
          set -euo pipefail
          
          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"

          echo "ğŸ“‹ Setting up Beta App Review Info with demo credentials..."
          echo "Bundle ID: $BUNDLE_ID"
          echo "Description: ${BETA_APP_DESCRIPTION:0:80}..."
          echo "Feedback Email: ${BETA_FEEDBACK_EMAIL}"
          echo "Contact Phone: ${BETA_CONTACT_PHONE}"
          echo ""
          echo "ğŸ” Demo Account Credentials:"
          echo "   Email: $DEMO_EMAIL"
          echo "   Password: $DEMO_PASSWORD"
          echo ""
          
          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "${BETA_APP_DESCRIPTION}" "${BETA_FEEDBACK_EMAIL}" "${BETA_CONTACT_PHONE}" "$DEMO_EMAIL" "$DEMO_PASSWORD" <<'PYEOF'
          import json, jwt, time, requests, sys
          
          api_key = json.load(open(sys.argv[1]))
          
          def create_token():
              return jwt.encode({
                  'iss': api_key['issuer_id'],
                  'iat': int(time.time()),
                  'exp': int(time.time()) + 1200,
                  'aud': 'appstoreconnect-v1'
              }, api_key['key'], algorithm='ES256',
              headers={'kid': api_key['key_id'], 'typ': 'JWT'})
          
          def h():
              return {
                  "Authorization": f"Bearer {create_token()}",
                  "Content-Type": "application/json"
              }
          
          bundle_id = sys.argv[2]
          beta_description = sys.argv[3]
          feedback_email = sys.argv[4]
          contact_phone = sys.argv[5]
          demo_email = sys.argv[6]
          demo_password = sys.argv[7]
          
          print("1ï¸âƒ£ Finding app in App Store Connect...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}",
              headers=h()
          )
          r.raise_for_status()
          apps = r.json()['data']
          
          if not apps:
              print(f"âŒ App not found: {bundle_id}")
              sys.exit(1)
          
          app_id = apps[0]['id']
          print(f"   âœ… App found: {app_id}")
          print()
          
          print("2ï¸âƒ£ Setting up Beta App Localization...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations?filter[app]={app_id}&filter[locale]=en-US",
              headers=h()
          )
          r.raise_for_status()
          
          localization_data = {
              "feedbackEmail": feedback_email,
              "description": beta_description
          }
          
          existing = r.json()['data']
          
          if existing:
              loc_id = existing[0]['id']
              r2 = requests.patch(
                  f"https://api.appstoreconnect.apple.com/v1/betaAppLocalizations/{loc_id}",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaAppLocalizations",
                          "id": loc_id,
                          "attributes": localization_data
                      }
                  }
              )
              
              if r2.status_code == 200:
                  print("   âœ… Beta app localization updated")
              else:
                  print(f"   âš ï¸  Update failed: {r2.status_code}")
          else:
              r2 = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaAppLocalizations",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaAppLocalizations",
                          "attributes": {
                              "locale": "en-US",
                              **localization_data
                          },
                          "relationships": {
                              "app": {"data": {"type": "apps", "id": app_id}}
                          }
                      }
                  }
              )
              
              if r2.status_code in (200, 201):
                  print("   âœ… Beta app localization created")
              else:
                  print(f"   âš ï¸  Creation failed: {r2.status_code}")
          
          print()
          
          print("3ï¸âƒ£ Setting up Beta App Review Detail with demo credentials...")
          try:
              r = requests.get(
                  f"https://api.appstoreconnect.apple.com/v1/apps/{app_id}/betaAppReviewDetail",
                  headers=h()
              )
              
              email_name = feedback_email.split('@')[0] if '@' in feedback_email else "Beta"
              first_name = email_name.split('.')[0].capitalize() if '.' in email_name else email_name.capitalize()
              last_name = email_name.split('.')[1].capitalize() if '.' in email_name and len(email_name.split('.')) > 1 else "Tester"
              
              review_data = {
                  "contactEmail": feedback_email,
                  "contactFirstName": first_name,
                  "contactLastName": last_name,
                  "contactPhone": contact_phone,
                  "demoAccountRequired": True,
                  "demoAccountName": demo_email,
                  "demoAccountPassword": demo_password
              }
              
              if r.status_code == 200:
                  detail_id = r.json()['data']['id']
                  print(f"   Updating existing review detail: {detail_id}")
                  
                  r2 = requests.patch(
                      f"https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails/{detail_id}",
                      headers=h(),
                      json={
                          "data": {
                              "type": "betaAppReviewDetails",
                              "id": detail_id,
                              "attributes": review_data
                          }
                      }
                  )
                  
                  if r2.status_code == 200:
                      print("   âœ… Beta review detail updated with demo credentials")
                      print(f"      Contact: {first_name} {last_name}")
                      print(f"      Email: {feedback_email}")
                      print(f"      Phone: {contact_phone}")
                      print(f"      Demo Account: {demo_email}")
                      print(f"      Demo Password: {'*' * len(demo_password)}")
                  else:
                      print(f"   âš ï¸  Update failed: {r2.status_code}")
                      print(r2.text)
              else:
                  print(f"   Creating new review detail...")
                  
                  r2 = requests.post(
                      "https://api.appstoreconnect.apple.com/v1/betaAppReviewDetails",
                      headers=h(),
                      json={
                          "data": {
                              "type": "betaAppReviewDetails",
                              "attributes": review_data,
                              "relationships": {
                                  "app": {"data": {"type": "apps", "id": app_id}}
                              }
                          }
                      }
                  )
                  
                  if r2.status_code in (200, 201):
                      print("   âœ… Beta review detail created with demo credentials")
                      print(f"      Contact: {first_name} {last_name}")
                      print(f"      Email: {feedback_email}")
                      print(f"      Phone: {contact_phone}")
                      print(f"      Demo Account: {demo_email}")
                      print(f"      Demo Password: {'*' * len(demo_password)}")
                  else:
                      print(f"   âš ï¸  Creation failed: {r2.status_code}")
                      print(r2.text)
                      
          except Exception as e:
              print(f"   âš ï¸  Error: {str(e)[:100]}")
          
          print()
          print("=" * 60)
          print("âœ… Beta metadata setup complete!")
          print("=" * 60)
          print("   ğŸ“‹ Beta App Localization: Configured")
          print("   ğŸ‘¤ Beta Review Contact: Configured")
          print("   ğŸ” Demo Credentials: Configured")
          print("   ğŸ“§ Feedback Email:", feedback_email)
          print("   ğŸ“± Contact Phone:", contact_phone)
          print("   ğŸ”‘ Demo Email:", demo_email)
          print()
          print("ğŸš€ Ready for external testing upload!")
          print("=" * 60)
          PYEOF

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PROVISIONING & EXPORT
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Ensure App ID exists
        shell: bash
        run: |
         set -euo pipefail
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          
          fastlane run produce \
            app_identifier:"$BUNDLE_ID" \
            team_id:"${IOS_TEAM_ID}" \
            api_key_path:"$GITHUB_WORKSPACE/.private/api_key.json" \
            skip_itc:false \
            language:"${APPLE_PRIMARY_LOCALE:-en-US}" \
            app_name:"${APPLE_APP_NAME:-Runner}" \
            sku:"${APPLE_SKU:-$BUNDLE_ID}" || true




      - name: Get provisioning profile
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"

          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILE_DIR"

          fastlane run sigh \
            app_identifier:"$BUNDLE_ID" \
            team_id:"${IOS_TEAM_ID}" \
            api_key_path:"$GITHUB_WORKSPACE/.private/api_key.json" \
            provisioning_name:"B4A_${BUNDLE_ID}_APPSTORE" \
            readonly:false \
            output_path:"$PROFILE_DIR"

          sleep 2

      - name: Detect provisioning profile name
        shell: bash
        run: |
          set -euo pipefail
          BUNDLE_ID="$(cat ci_ios_bundle_id.txt | tr -d '\r\n')"
          APP_ID="${IOS_TEAM_ID}.${BUNDLE_ID}"

          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"

          FOUND_NAME=""
          
          for f in "$PROFILES_DIR"/*.mobileprovision; do
            [ -f "$f" ] || continue
            
            TMP_PLIST="$(mktemp /tmp/profile.XXXXXX.plist)"
            /usr/bin/security cms -D -i "$f" > "$TMP_PLIST" 2>/dev/null || {
              rm -f "$TMP_PLIST"
              continue
            }

            P_NAME=$("/usr/libexec/PlistBuddy" -c "Print :Name" "$TMP_PLIST" 2>/dev/null || echo "Unknown")
            P_APPID=$("/usr/libexec/PlistBuddy" -c "Print :Entitlements:application-identifier" "$TMP_PLIST" 2>/dev/null || echo "")
            
            if [ "$P_APPID" = "$APP_ID" ] || [ "$P_APPID" = "${IOS_TEAM_ID}.*" ] || echo "$P_APPID" | grep -q "$BUNDLE_ID"; then
              FOUND_NAME="$P_NAME"
              echo "$FOUND_NAME" > ci_profile_name.txt
              rm -f "$TMP_PLIST"
              break
            fi
            
            rm -f "$TMP_PLIST"
          done

          if [ -z "$FOUND_NAME" ]; then
            echo "âŒ No provisioning profile matched"
            exit 1
          fi

          echo "âœ… Profile: $FOUND_NAME"

      - name: Create ExportOptions.plist
        shell: bash
        run: |
          set -euo pipefail

          METHOD="${IOS_EXPORT_METHOD:-app-store}"
          TEAM="${IOS_TEAM_ID}"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          PROFILE_NAME="$(tr -d '\r\n' < ci_profile_name.txt)"

          cat > ios/ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>${METHOD}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>teamID</key>
            <string>${TEAM}</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key>
              <string>${PROFILE_NAME}</string>
            </dict>
            <key>destination</key>
            <string>export</string>
            <key>compileBitcode</key>
            <false/>
          </dict>
          </plist>
          EOF

          /usr/bin/plutil -lint ios/ExportOptions.plist

      - name: Patch Runner signing
        shell: bash
        run: |
          set -euo pipefail

          gem install xcodeproj -N

          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          PROFILE_NAME="$(tr -d '\r\n' < ci_profile_name.txt)"
          TEAM_ID="${IOS_TEAM_ID}"

          cat > patch_runner_signing.rb <<'RUBY'
          require "xcodeproj"

          bundle_id = ENV.fetch("BUNDLE_ID")
          profile   = ENV.fetch("PROFILE_NAME")
          team_id   = ENV.fetch("TEAM_ID")

          proj_path = "ios/Runner.xcodeproj"
          project = Xcodeproj::Project.open(proj_path)

          runner = project.targets.find { |t| t.name == "Runner" }
          raise "Runner target not found" unless runner

          runner.build_configurations.each do |cfg|
            next unless cfg.name == "Release"
            s = cfg.build_settings

            s["PRODUCT_BUNDLE_IDENTIFIER"] = bundle_id
            s["CODE_SIGN_STYLE"] = "Manual"
            s["DEVELOPMENT_TEAM"] = team_id
            s["CODE_SIGN_IDENTITY"] = "Apple Distribution"
            s["PROVISIONING_PROFILE_SPECIFIER"] = profile
            s["CODE_SIGNING_ALLOWED"] = "YES"
            s["CODE_SIGNING_REQUIRED"] = "YES"
          end

          project.save
          RUBY

          BUNDLE_ID="$BUNDLE_ID" PROFILE_NAME="$PROFILE_NAME" TEAM_ID="$TEAM_ID" ruby patch_runner_signing.rb

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # BUILD, ARCHIVE, EXPORT
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Build iOS
        shell: bash
        run: |
          set -euo pipefail
          flutter build ios --release --no-codesign \
            --dart-define-from-file=lib/env/ci_env.json

      - name: Force Pods = no signing
        shell: bash
        run: |
          set -euo pipefail
          PODS_PBX="ios/Pods/Pods.xcodeproj/project.pbxproj"
          
          perl -pi -e 's/(PROVISIONING_PROFILE_SPECIFIER(\[sdk=iphoneos\*\])?) = [^;]*;/\1 = "";/g' "$PODS_PBX"
          perl -pi -e 's/PROVISIONING_PROFILE = [^;]*;/PROVISIONING_PROFILE = "";/g' "$PODS_PBX"
          perl -pi -e 's/DEVELOPMENT_TEAM = [A-Z0-9]+;/DEVELOPMENT_TEAM = "";/g' "$PODS_PBX"
          perl -pi -e 's/(CODE_SIGN_IDENTITY(\[sdk=iphoneos\*\])?) = [^;]*;/\1 = "";/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGNING_ALLOWED = YES;/CODE_SIGNING_ALLOWED = NO;/g' "$PODS_PBX"
          perl -pi -e 's/CODE_SIGNING_REQUIRED = YES;/CODE_SIGNING_REQUIRED = NO;/g' "$PODS_PBX"

      - name: Archive
        shell: bash
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/archive
          cd ios

          xcodebuild \
            -workspace Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            archive

      - name: Export IPA
        shell: bash
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="${GITHUB_WORKSPACE}/build.keychain"
          KEYCHAIN_PWD="ci_keychain_pwd_123"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH" || true

          mkdir -p build/ios/ipa
          cd ios

          xcodebuild -exportArchive \
            -archivePath ../build/ios/archive/Runner.xcarchive \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath ../build/ios/ipa \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa
          path: build/ios/ipa/**/*.ipa
          if-no-files-found: error

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # TESTFLIGHT UPLOAD & EXTERNAL TESTING SETUP
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Upload to TestFlight (External Testing)
        shell: bash
        run: |
          set -euo pipefail
          
          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          IPA_PATH="$(find "$GITHUB_WORKSPACE/build/ios/ipa" -type f -name "*.ipa" | head -n 1)"
          
          echo "ğŸ“¤ Uploading to TestFlight for External Testing..."
          echo "âš ï¸  Note: External builds require Apple's beta review (24-48 hours)"
          
           fastlane pilot upload \
            --ipa "$IPA_PATH" \
            --api_key_path "$API_KEY_JSON" \
            --app_identifier "$BUNDLE_ID" \
            --skip_waiting_for_build_processing false \
            --distribute_external false \
            --skip_submission true \
            --changelog "Initial beta release for testing"

      
          echo "âœ… Upload complete!"
          echo "â³ Build submitted for external beta review"

      - name: ğŸš€ Complete External TestFlight Setup (Dynamic)
        shell: bash
        run: |
          set -euo pipefail
          
          
          API_KEY_JSON="$GITHUB_WORKSPACE/.private/api_key.json"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          APP_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json'))['APP_NAME'])")"
          
       
          python3 - <<'PY'
          import json, pathlib
          payload = json.loads(r'''${{ toJson(github.event.client_payload) }}''') or {}
          pathlib.Path("/tmp/ci_payload.json").write_text(json.dumps(payload), encoding="utf-8")
          print("âœ… wrote /tmp/ci_payload.json")
          PY
          
          
          python3 - <<'PY' > /tmp/owner_env.sh
          import json, shlex
          p = json.load(open("/tmp/ci_payload.json"))
          cfg = p.get("CONFIG") or {}
          owner_email = (cfg.get("ownerEmail") or "").strip()
          owner_name  = (cfg.get("ownerName") or "Owner").strip() or "Owner"
          print("OWNER_EMAIL=" + shlex.quote(owner_email))
          print("OWNER_NAME="  + shlex.quote(owner_name))
          PY
          
          source /tmp/owner_env.sh
          
          if [ -z "${OWNER_EMAIL:-}" ]; then
            echo "âš ï¸ ownerEmail not provided, skipping TestFlight setup"
            exit 0
          fi
          
          echo "ğŸ“§ Owner: $OWNER_EMAIL ($OWNER_NAME)"
          echo "ğŸ“± App: $APP_NAME"
          echo "ğŸ†” Bundle: $BUNDLE_ID"
          echo ""
          
          python3 - "$API_KEY_JSON" "$BUNDLE_ID" "$OWNER_EMAIL" "$OWNER_NAME" "$APP_NAME" "${BETA_APP_DESCRIPTION:-}" "${BETA_FEEDBACK_EMAIL:-}" "${BETA_CONTACT_PHONE:-}" <<'PYEOF'
          import json, jwt, time, requests, sys, os
          
          api_key = json.load(open(sys.argv[1]))
          
          def create_token():
              return jwt.encode({
                  "iss": api_key["issuer_id"],
                  "iat": int(time.time()),
                  "exp": int(time.time()) + 1200,
                  "aud": "appstoreconnect-v1"
              }, api_key["key"], algorithm="ES256",
              headers={"kid": api_key["key_id"], "typ": "JWT"})
          
          def h():
              return {"Authorization": f"Bearer {create_token()}", "Content-Type": "application/json"}
          
          bundle_id        = sys.argv[2]
          owner_email      = sys.argv[3]
          owner_name       = sys.argv[4]
          app_name         = sys.argv[5]
          beta_description = sys.argv[6] if len(sys.argv) > 6 and sys.argv[6] else f"Test {app_name} and provide feedback"
          feedback_email   = sys.argv[7] if len(sys.argv) > 7 and sys.argv[7] else owner_email
          contact_phone    = sys.argv[8] if len(sys.argv) > 8 and sys.argv[8] else "+1234567890"
          
          print("="*70)
          print("ğŸš€ COMPLETE EXTERNAL TESTFLIGHT SETUP")
          print("="*70)
          print(f"ğŸ“§ Feedback Email: {feedback_email}")
          print(f"ğŸ“± Contact Phone: {contact_phone}")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 1: Find app
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ“± Step 1: Finding app in App Store Connect...")
          r = requests.get(f"https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}", headers=h())
          r.raise_for_status()
          apps = r.json().get("data", [])
          if not apps:
              print(f"âŒ App not found: {bundle_id}")
              sys.exit(1)
          app_id = apps[0]["id"]
          print(f"   âœ… App found: {app_id}")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 2: Ensure beta tester exists
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ§ª Step 2: Setting up external beta tester...")
          tester_id = None
          
          try:
              r = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaTesters?filter[email]={owner_email}", headers=h())
              if r.status_code == 200:
                  data = r.json().get("data", [])
                  if data:
                      tester_id = data[0]["id"]
                      print(f"   âœ… Beta tester exists: {tester_id}")
          except Exception as e:
              print(f"   âš ï¸  Error checking testers: {str(e)[:100]}")
          
          if not tester_id:
              try:
                  print("   âš™ï¸  Creating external beta tester...")
                  first = owner_name.split()[0] if owner_name.strip() else "Owner"
                  last  = " ".join(owner_name.split()[1:]) if len(owner_name.split()) > 1 else ""
          
                  r = requests.post(
                      "https://api.appstoreconnect.apple.com/v1/betaTesters",
                      headers=h(),
                      json={"data":{"type":"betaTesters","attributes":{"email": owner_email,"firstName": first,"lastName": last}}}
                  )
          
                  if r.status_code in (200, 201):
                      tester_id = r.json()["data"]["id"]
                      print(f"   âœ… External beta tester created: {tester_id}")
                  elif r.status_code == 409:
                      # already exists somewhere; re-fetch
                      r2 = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaTesters?filter[email]={owner_email}", headers=h())
                      if r2.status_code == 200:
                          data = r2.json().get("data", [])
                          if data:
                              tester_id = data[0]["id"]
                              print(f"   âœ… Found existing tester: {tester_id}")
                  else:
                      print(f"   âš ï¸  Beta tester creation: HTTP {r.status_code}")
                      print(r.text[:300])
              except Exception as e:
                  print(f"   âš ï¸  Error creating tester: {str(e)[:100]}")
          
          if not tester_id:
              print("   âš ï¸ Could not create/find beta tester â€” will continue without adding tester to group.")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 3: Ensure external group exists + public link enabled
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ‘¥ Step 3: Setting up external testing group with public link...")
          r = requests.get(
              f"https://api.appstoreconnect.apple.com/v1/betaGroups?filter[app]={app_id}&filter[isInternalGroup]=false",
              headers=h()
          )
          r.raise_for_status()
          groups = r.json().get("data", [])
          
          group_id = None
          group_name = None
          public_link_enabled = False
          
          for g in groups:
              if g.get("attributes", {}).get("publicLinkEnabled", False):
                  group_id = g["id"]
                  group_name = g["attributes"]["name"]
                  public_link_enabled = True
                  print(f"   âœ… Public external group exists: '{group_name}'")
                  break
          
          if not group_id and groups:
              group_id = groups[0]["id"]
              group_name = groups[0]["attributes"]["name"]
              public_link_enabled = groups[0]["attributes"].get("publicLinkEnabled", False)
              print(f"   âœ… External group exists: '{group_name}'")
          
          if not group_id:
              print("   âš™ï¸  Creating external testing group with public link...")
              r = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaGroups",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaGroups",
                          "attributes": {
                              "name": "External Testers",
                              "isInternalGroup": False,
                              "publicLinkEnabled": True,
                              "publicLinkLimitEnabled": False
                          },
                          "relationships": {"app": {"data": {"type": "apps", "id": app_id}}}
                      }
                  }
              )
              if r.status_code in (200, 201):
                  gd = r.json()["data"]
                  group_id = gd["id"]
                  group_name = gd["attributes"]["name"]
                  public_link_enabled = True
                  print(f"   âœ… External group created: '{group_name}'")
              else:
                  print(f"   âŒ Could not create external group (HTTP {r.status_code})")
                  print(r.text[:300])
                  sys.exit(1)
          
          if not public_link_enabled:
              print(f"   âš™ï¸  Enabling public link on group '{group_name}'...")
              try:
                  r = requests.patch(
                      f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}",
                      headers=h(),
                      json={"data":{"type":"betaGroups","id": group_id,"attributes":{"publicLinkEnabled": True,"publicLinkLimitEnabled": False}}}
                  )
                  if r.status_code == 200:
                      print("   âœ… Public link enabled")
                      public_link_enabled = True
                  else:
                      print(f"   âš ï¸  Could not enable public link: HTTP {r.status_code}")
                      print(r.text[:300])
              except Exception as e:
                  print(f"   âš ï¸  Error enabling public link: {str(e)[:100]}")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 4: Retrieve public link (may be empty initially)
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ”— Step 4: Retrieving public TestFlight link...")
          public_testflight_link = None
          try:
              r = requests.get(f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}", headers=h())
              if r.status_code == 200:
                  public_testflight_link = r.json()["data"]["attributes"].get("publicLink")
                  if public_testflight_link:
                      print("   âœ… Public TestFlight Link:")
                      print(f"   ğŸ”— {public_testflight_link}")
                      with open("testflight_public_link.txt", "w") as f:
                          f.write(public_testflight_link)
                  else:
                      print("   âš ï¸  Public link not available yet (often appears after first processing/review)")
              else:
                  print(f"   âš ï¸  Could not retrieve group details: HTTP {r.status_code}")
          except Exception as e:
              print(f"   âš ï¸  Error retrieving public link: {str(e)[:100]}")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 5: Add tester to group (SAFE â€” no duplicate r usage)
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ”— Step 5: Adding tester to external group...")
          if tester_id:
              r = requests.post(
                  f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/betaTesters",
                  headers=h(),
                  json={"data":[{"type":"betaTesters","id":tester_id}]}
              )
              if r.status_code in (200, 204):
                  print("   âœ… Tester added to external group")
              elif r.status_code == 409:
                  print("   âœ… Tester already in external group")
              else:
                  print(f"   âš ï¸  Add tester response: HTTP {r.status_code}")
                  print(r.text[:300])
          else:
              print("   âš ï¸ tester_id missing â€” skipping add-tester step.")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 6: Wait for latest build to be VALID
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("â³ Step 6: Waiting for build to finish processing...")
          build_id = version = build_num = None
          max_retries = 20
          
          for attempt in range(max_retries):
              r = requests.get(
                  f"https://api.appstoreconnect.apple.com/v1/builds?filter[app]={app_id}&sort=-uploadedDate&limit=1",
                  headers=h()
              )
              r.raise_for_status()
              builds = r.json().get("data", [])
          
              if builds:
                  b = builds[0]
                  build_id = b["id"]
                  version = b["attributes"].get("version")
                  build_num = b["attributes"].get("buildNumber", "")
                  state = b["attributes"].get("processingState", "PROCESSING")
          
                  if state == "VALID":
                      print(f"   âœ… Build ready: {version} ({build_num})")
                      break
                  print(f"   â³ Build {version} {state} - attempt {attempt+1}/{max_retries}")
              else:
                  print(f"   â³ No builds found yet - attempt {attempt+1}/{max_retries}")
          
              if attempt < max_retries - 1:
                  time.sleep(30)
          
          if not build_id:
              print("\n   âš ï¸  Build not ready yet")
              with open("testflight_status.txt", "w") as f:
                  f.write("PENDING_BUILD")
              if public_testflight_link:
                  print("="*70)
                  print("ğŸ”— PUBLIC TESTFLIGHT LINK (Ready to share)")
                  print("="*70)
                  print(public_testflight_link)
                  print("="*70)
              sys.exit(0)
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 7: Export compliance
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ”’ Step 7: Setting export compliance...")
          try:
              r = requests.patch(
                  f"https://api.appstoreconnect.apple.com/v1/builds/{build_id}",
                  headers=h(),
                  json={"data":{"type":"builds","id": build_id,"attributes":{"usesNonExemptEncryption": False}}}
              )
              if r.status_code == 200:
                  print("   âœ… Export compliance set")
                  time.sleep(5)
              elif r.status_code == 409:
                  print("   âœ… Export compliance already set")
              else:
                  print(f"   â„¹ï¸  Export compliance: HTTP {r.status_code}")
                  print(r.text[:200])
          except Exception as e:
              print(f"   âš ï¸  {str(e)[:80]}")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 8: Beta build localization (WhatsNew)
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ“ Step 8: Adding beta build localization...")
          try:
              whats_new_text = f"Welcome to {app_name} beta! Please test all features and provide feedback."
              r = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaBuildLocalizations",
                  headers=h(),
                  json={
                      "data": {
                          "type": "betaBuildLocalizations",
                          "attributes": {"locale": "en-US", "whatsNew": whats_new_text},
                          "relationships": {"build": {"data": {"type": "builds", "id": build_id}}}
                      }
                  }
              )
              if r.status_code in (200, 201):
                  print("   âœ… Beta build localization added")
              elif r.status_code == 409:
                  print("   âœ… Beta build localization already exists")
              else:
                  print(f"   â„¹ï¸  Beta localization response: HTTP {r.status_code}")
                  print(r.text[:200])
          except Exception as e:
              print(f"   âš ï¸  {str(e)[:80]}")
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 9: Add build to external group
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ“¦ Step 9: Adding build to external testing group...")
          build_added = False
          for attempt in range(15):
              r = requests.post(
                  f"https://api.appstoreconnect.apple.com/v1/betaGroups/{group_id}/relationships/builds",
                  headers=h(),
                  json={"data":[{"type":"builds","id": build_id}]}
              )
              if r.status_code in (200, 204, 409):
                  print("   âœ… Build added (or already present)")
                  build_added = True
                  break
              if r.status_code == 422:
                  print(f"   â³ Not ready yet - attempt {attempt+1}/15")
                  time.sleep(30)
                  continue
              print(f"   âš ï¸  Add build response: HTTP {r.status_code}")
              print(r.text[:200])
              time.sleep(30)
          print()
          
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Step 10: Submit for beta review
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print("ğŸ“‹ Step 10: Submitting build for Beta App Review...")
          review_submitted = False
          try:
              r = requests.post(
                  "https://api.appstoreconnect.apple.com/v1/betaAppReviewSubmissions",
                  headers=h(),
                  json={"data":{"type":"betaAppReviewSubmissions","relationships":{"build":{"data":{"type":"builds","id": build_id}}}}}
              )
              if r.status_code in (200, 201, 409):
                  print("   âœ… Submitted (or already submitted)")
                  review_submitted = True
              else:
                  print(f"   âš ï¸  Submit response: HTTP {r.status_code}")
                  print(r.text[:300])
          except Exception as e:
              print(f"   âš ï¸  Error submitting for review: {str(e)[:100]}")
          print()
          
          status = "SUBMITTED_FOR_REVIEW" if review_submitted else "BUILD_ADDED"
          with open("testflight_status.txt", "w") as f:
              f.write(status)
          
          print("="*70)
          if build_added and review_submitted:
              print("ğŸ‰ âœ… EXTERNAL TESTING FULLY CONFIGURED!")
              print(f"ğŸ“§ Owner: {owner_email}")
              print(f"ğŸ“± App: {app_name}")
              print(f"ğŸ“¦ Build: {version} ({build_num})")
              print(f"ğŸ‘¥ Group: {group_name}")
              if public_testflight_link:
                  print(f"ğŸ”— Public Link: {public_testflight_link}")
                  print("â³ Link typically becomes usable after Apple beta review approval (24-48h).")
          else:
              print("âš ï¸  SETUP PARTIALLY COMPLETE (build processing / group/link might still be pending)")
              if public_testflight_link:
                  print(f"ğŸ”— Public Link (if available): {public_testflight_link}")
          print("="*70)
          PYEOF

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # ğŸ’¾ CALLBACK â€“ save TestFlight link to DB, uses $DEMO_EMAIL /
      #    $DEMO_PASSWORD from GITHUB_ENV everywhere (no hardcoding)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ’¾ Save TestFlight link into ipaUrl column
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          API_BASE="$(tr -d '\r\n' < ci_api_base.txt)"
          LINK_ID="$(tr -d '\r\n' < ci_link_id.txt)"
          BUNDLE_ID="$(tr -d '\r\n' < ci_ios_bundle_id.txt)"
          APP_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json')).get('APP_NAME',''))")"
          VERSION_NAME="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json')).get('IOS_VERSION_NAME',''))")"
          BUILD_NUMBER="$(python3 -c "import json; print(json.load(open('lib/env/ci_env.json')).get('IOS_BUILD_NUMBER',''))")"

          # Read public link (may not exist yet)
          TESTFLIGHT_LINK=""
          if [ -f "testflight_public_link.txt" ]; then
            TESTFLIGHT_LINK="$(tr -d '\r\n' < testflight_public_link.txt)"
          fi

          echo "API_BASE=$API_BASE"
          echo "LINK_ID=$LINK_ID"
          echo "BUNDLE_ID=$BUNDLE_ID"
          echo "APP_NAME=$APP_NAME"
          echo "VERSION=$VERSION_NAME ($BUILD_NUMBER)"
          echo "TESTFLIGHT_LINK=${TESTFLIGHT_LINK:-EMPTY}"

          # If link is empty, don't overwrite ipaUrl with empty string
          if [ -z "${TESTFLIGHT_LINK:-}" ]; then
            echo "âš ï¸ No TestFlight public link available yet -> skipping ipaUrl save"
            {
              echo "## â„¹ï¸ TestFlight Link Not Available Yet"
              echo ""
              echo "- Bundle: \`$BUNDLE_ID\`"
              echo "- App: \`$APP_NAME\`"
              echo "- Version: \`$VERSION_NAME ($BUILD_NUMBER)\`"
              echo ""
              echo "> Public link is often generated only after Apple processes the first build / review settings are complete."
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          # Must have CI_CALLBACK_TOKEN
          if [ -z "${CI_CALLBACK_TOKEN:-}" ]; then
            echo "âŒ CI_CALLBACK_TOKEN missing -> cannot save ipaUrl"
            exit 1
          fi

          CALLBACK_URL="$API_BASE/api/ci/owner-project-links/$LINK_ID/ipa-url"

          echo ""
          echo "ğŸ“¡ Saving ipaUrl via: $CALLBACK_URL"

          # jq is not guaranteed; build JSON safely without it
          export TESTFLIGHT_LINK

          PAYLOAD="$(python3 - <<'PY'
          import os, json
          print(json.dumps({"ipaUrl": os.environ["TESTFLIGHT_LINK"]}))
          PY
          )"


          echo "$PAYLOAD"

          RESPONSE="$(curl -sS -w "\n%{http_code}" -X PUT "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Token: $CI_CALLBACK_TOKEN" \
            -d "$PAYLOAD" 2>&1)"

          HTTP_CODE="$(echo "$RESPONSE" | tail -n1)"
          BODY="$(echo "$RESPONSE" | sed '$d')"

          echo ""
          echo "HTTP $HTTP_CODE"
          echo "$BODY" | python3 -m json.tool 2>/dev/null || echo "$BODY"

          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "201" ]; then
            echo "âš ï¸ Failed to save ipaUrl (NON-BLOCKING)"
            {
              echo "## âš ï¸ Failed to save TestFlight link to DB (non-blocking)"
              echo ""
              echo "- Endpoint: \`$CALLBACK_URL\`"
              echo "- HTTP: \`$HTTP_CODE\`"
              echo ""
              echo "Response:"
              echo "\`\`\`"
              echo "$BODY"
              echo "\`\`\`"
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi


          echo "âœ… Saved TestFlight link into ipaUrl column"

          {
            echo "## âœ… TestFlight link saved"
            echo ""
            echo "| Field | Value |"
            echo "|---|---|"
            echo "| App | $APP_NAME |"
            echo "| Bundle | $BUNDLE_ID |"
            echo "| Version | $VERSION_NAME ($BUILD_NUMBER) |"
            echo "| Link | \`$TESTFLIGHT_LINK\` |"
            echo ""
            echo "> Note: Link can exist while build is still processing / waiting for beta review."
          } >> "$GITHUB_STEP_SUMMARY"

          if [ -f "testflight_status.txt" ]; then
            BUILD_STATUS="$(cat testflight_status.txt)"
          else
            BUILD_STATUS="UNKNOWN"
          fi
          
          # Determine if save was successful
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
            SUCCESS="true"
          else
            SUCCESS="false"
          fi

          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "                    ğŸ‰ BUILD COMPLETE ğŸ‰"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“± App Name:       $APP_NAME"
          echo "ğŸ†” Bundle ID:      $BUNDLE_ID"
          echo "ğŸ“¦ Version:        $VERSION_NAME ($BUILD_NUMBER)"
          echo "ğŸ“‹ Status:         $BUILD_STATUS"
          echo "ğŸ’¾ Saved to DB:    $([ "$SUCCESS" = "true" ] && echo "âœ… YES" || echo "âŒ NO")"
          echo ""
          
          if [ -n "$TESTFLIGHT_LINK" ]; then
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "           ğŸ”— PUBLIC TESTFLIGHT LINK (Ready to Share)"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "$TESTFLIGHT_LINK"
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“² SHARE THIS LINK WITH BETA TESTERS"
            echo ""
            echo "â³ IMPORTANT NOTES:"
            echo "   â€¢ Link is active immediately"
            echo "   â€¢ Build requires Apple Beta Review (24-48 hours)"
            echo "   â€¢ Testers will receive email when build is approved"
            echo "   â€¢ Testers need TestFlight app installed"
            echo ""
            echo "ğŸ” DEMO CREDENTIALS (from endpoint):"
            echo "   ğŸ“§ Email:    $DEMO_EMAIL"
            echo "   ğŸ”‘ Password: $DEMO_PASSWORD"
            echo ""
            echo "ğŸ“§ WHAT TESTERS SHOULD DO:"
            echo "   1. Install TestFlight app from App Store"
            echo "   2. Click the public link above (or received via email)"
            echo "   3. Accept the invitation"
            echo "   4. Wait for Apple approval notification"
            echo "   5. Download and test the app"
            echo ""
          else
            echo "â„¹ï¸  TestFlight Link: Will be available after first build approval"
            echo ""
          fi
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # â”€â”€â”€ GitHub Step Summary â”€â”€â”€
          {
            echo "## ğŸ‰ iOS Build Complete"
            echo ""
            echo "| Field | Value |"
            echo "|---|---|"
            echo "| App Name | $APP_NAME |"
            echo "| Bundle ID | $BUNDLE_ID |"
            echo "| Version | $VERSION_NAME ($BUILD_NUMBER) |"
            echo "| Status | $BUILD_STATUS |"
            echo "| Saved to DB | $([ "$SUCCESS" = "true" ] && echo 'âœ… Yes' || echo 'âŒ No') |"
            echo ""
            
            if [ -n "$TESTFLIGHT_LINK" ]; then
              echo "### ğŸ”— Public TestFlight Link"
              echo ""
              echo "\`\`\`"
              echo "$TESTFLIGHT_LINK"
              echo "\`\`\`"
              echo ""
              echo "**Demo Credentials (from endpoint):**"
              echo "- Email: \`$DEMO_EMAIL\`"
              echo "- Password: \`$DEMO_PASSWORD\`"
              echo ""
              echo "### ğŸ“² Next Steps"
              echo ""
              echo "1. âœ… Share the TestFlight link with beta testers"
              echo "2. â³ Apple will review the build (24-48 hours)"
              echo "3. ğŸ“§ Testers will receive email notification when approved"
              echo "4. ğŸ“± Testers install TestFlight app and access the build"
              echo ""

              MAX_ATTEMPTS="${MAX_ATTEMPTS:-1}"

              if [ "$SUCCESS" = "true" ]; then
                echo "### âœ… Database Status"
                echo ""
                echo "TestFlight public link has been successfully saved to your database."
                echo ""
              else
                echo "### âš ï¸ Database Status"
                echo ""
                echo "**Warning:** Failed to save TestFlight link to database after $MAX_ATTEMPTS attempts."
                echo ""
                echo "**Troubleshooting:**"
                echo "- Check if backend endpoint is accessible: \`$CALLBACK_URL\`"
                echo "- Verify \`CI_CALLBACK_TOKEN\` secret is set correctly"
                echo "- Review backend logs for errors"
                echo ""
              fi
            else
              echo "> â„¹ï¸ Public TestFlight link will be available after Apple approves the first build."
              echo ""
              echo "Once available, the link will be automatically saved to your database on the next build."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

        



              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # FINAL STATUS UPDATE (runs always, reports SUCCESS or FAILED)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ“¡ Report final status to backend
        if: always()
        shell: bash
        run: |
          set +e
          
          # Read from files (fallback safe)
          API_BASE="$(cat ci_api_base.txt 2>/dev/null | tr -d '\r\n')"
          LINK_ID="$(cat ci_link_id.txt 2>/dev/null | tr -d '\r\n')"
          
          if [ -z "$API_BASE" ] || [ -z "${CI_CALLBACK_TOKEN:-}" ]; then
            echo "âš ï¸ API_BASE or CI_CALLBACK_TOKEN missing, skipping final status"
            exit 0
          fi
          
          JOB_STATUS="${{ job.status }}"
          
          if [ "$JOB_STATUS" = "success" ]; then
            echo "âœ… Job succeeded â†’ marking SUCCEEDED"
            curl -sS -X PUT "${API_BASE}/api/ci/build-jobs/succeeded" \
              -H "Content-Type: application/json" \
              -H "X-Auth-Token: ${CI_CALLBACK_TOKEN}" \
              -d "{\"buildId\":\"${BUILD_ID}\",\"linkId\":\"${LINK_ID}\",\"platform\":\"IOS\"}" || true
          else
            echo "âŒ Job failed/cancelled â†’ marking FAILED"
            ERROR_MSG="iOS build ${JOB_STATUS} (see GitHub Actions logs for details)"
            curl -sS -X PUT "${API_BASE}/api/ci/build-jobs/failed" \
              -H "Content-Type: application/json" \
              -H "X-Auth-Token: ${CI_CALLBACK_TOKEN}" \
              -d "{\"buildId\":\"${BUILD_ID}\",\"linkId\":\"${LINK_ID}\",\"platform\":\"IOS\",\"error\":\"${ERROR_MSG}\"}" || true
          fi
          
          echo "âœ… Final status reported"

